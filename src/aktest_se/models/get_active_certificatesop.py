"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from aktest_se.types import BaseModel, Nullable, OptionalNullable, UNSET, UNSET_SENTINEL
from aktest_se.utils import FieldMetadata, QueryParamMetadata
from datetime import datetime
from enum import Enum
import pydantic
from pydantic import model_serializer
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class GetActiveCertificatesRequestTypedDict(TypedDict):
    contract_id: str
    r"""Specify the contract on which to operate or view."""
    account_switch_key: NotRequired[str]
    r"""For customers who manage more than one account, this [runs the operation from another account](https://techdocs.akamai.com/developer/docs/manage-many-accounts-with-one-api-client). The Identity and Access Management API provides a [list of available account switch keys](https://techdocs.akamai.com/iam-api/reference/get-client-account-switch-keys)."""


class GetActiveCertificatesRequest(BaseModel):
    contract_id: Annotated[
        str,
        pydantic.Field(alias="contractId"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ]
    r"""Specify the contract on which to operate or view."""

    account_switch_key: Annotated[
        Optional[str],
        pydantic.Field(alias="accountSwitchKey"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""For customers who manage more than one account, this [runs the operation from another account](https://techdocs.akamai.com/developer/docs/manage-many-accounts-with-one-api-client). The Identity and Access Management API provides a [list of available account switch keys](https://techdocs.akamai.com/iam-api/reference/get-client-account-switch-keys)."""


class GetActiveCertificatesCertificateType(str, Enum):
    r"""Specifies the kind of certificate in the enrollment. Either `san`, `single`, `wildcard`, `wildcard-san`, or `third-party`. For details, see `validationType` in the [Enrollment object's versioned schema members](ref:enrollment#versioned-schema-members)."""

    SAN = "san"
    SINGLE = "single"
    WILDCARD = "wildcard"
    WILDCARD_SAN = "wildcard-san"
    THIRD_PARTY = "third-party"


class GetActiveCertificatesCsrTypedDict(TypedDict):
    r"""When you create an enrollment, CPS also generates a certificate signing request (CSR). CPS signs the CSR with the private key. The CSR contains all the information the CA needs to issue your certificate."""

    cn: NotRequired[str]
    r"""The domain name to use for the certificate, also known as the _common name_. Note that the organization specified as the `o` needs to own or have legal rights to this domain name."""
    sans: NotRequired[Nullable[List[str]]]
    r"""Additional `cn` values to create a Subject Alternative Names (SAN) list."""


class GetActiveCertificatesCsr(BaseModel):
    r"""When you create an enrollment, CPS also generates a certificate signing request (CSR). CPS signs the CSR with the private key. The CSR contains all the information the CA needs to issue your certificate."""

    cn: Optional[str] = None
    r"""The domain name to use for the certificate, also known as the _common name_. Note that the organization specified as the `o` needs to own or have legal rights to this domain name."""

    sans: OptionalNullable[List[str]] = UNSET
    r"""Additional `cn` values to create a Subject Alternative Names (SAN) list."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["cn", "sans"]
        nullable_fields = ["sans"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetActiveCertificatesChangeType(str, Enum):
    r"""Indicates the certificate's pending change action. This is either `new-certificate`, `modify-certificate`, `modify-san`, or `renewal`."""

    NEW_CERTIFICATE = "new-certificate"
    MODIFY_CERTIFICATE = "modify-certificate"
    MODIFY_SAN = "modify-san"
    RENEWAL = "renewal"


class GetActiveCertificatesPendingChangesTypedDict(TypedDict):
    change_type: NotRequired[Nullable[GetActiveCertificatesChangeType]]
    r"""Indicates the certificate's pending change action. This is either `new-certificate`, `modify-certificate`, `modify-san`, or `renewal`."""
    location: NotRequired[str]
    r"""URL to fetch related change information."""


class GetActiveCertificatesPendingChanges(BaseModel):
    change_type: Annotated[
        OptionalNullable[GetActiveCertificatesChangeType],
        pydantic.Field(alias="changeType"),
    ] = UNSET
    r"""Indicates the certificate's pending change action. This is either `new-certificate`, `modify-certificate`, `modify-san`, or `renewal`."""

    location: Optional[str] = None
    r"""URL to fetch related change information."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["changeType", "location"]
        nullable_fields = ["changeType"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetActiveCertificatesCertificatesResponse200KeyAlgorithm(str, Enum):
    r"""The key algorithm of the certificate. This is either `ECDSA` or `RSA`."""

    ECDSA = "ECDSA"
    RSA = "RSA"


class GetActiveCertificatesCertificatesResponse200SignatureAlgorithm(str, Enum):
    r"""Indicates the SHA (Secure Hash Algorithm) function. You can use either `SHA-1` for a 160-bit (20-byte) hash or `SHA-256` for a 256-bit (32-byte) hash."""

    SHA_1 = "SHA-1"
    SHA_256 = "SHA-256"


class GetActiveCertificatesCertificatesMultiStackedCertificatesTypedDict(TypedDict):
    expiry: NotRequired[str]
    r"""The expiration date for the certificate."""
    issuer: NotRequired[str]
    r"""Entity that has verified the certificate's contents."""
    key_algorithm: NotRequired[GetActiveCertificatesCertificatesResponse200KeyAlgorithm]
    r"""The key algorithm of the certificate. This is either `ECDSA` or `RSA`."""
    serial: NotRequired[Nullable[str]]
    r"""Serial number that uniquely identifies each certificate."""
    sha256_fingerprint: NotRequired[str]
    r"""A digital fingerprint, formatted as 32 pairs of hexadecimal digits separated by ':'."""
    signature_algorithm: NotRequired[
        Nullable[GetActiveCertificatesCertificatesResponse200SignatureAlgorithm]
    ]
    r"""Indicates the SHA (Secure Hash Algorithm) function. You can use either `SHA-1` for a 160-bit (20-byte) hash or `SHA-256` for a 256-bit (32-byte) hash."""


class GetActiveCertificatesCertificatesMultiStackedCertificates(BaseModel):
    expiry: Optional[str] = None
    r"""The expiration date for the certificate."""

    issuer: Optional[str] = None
    r"""Entity that has verified the certificate's contents."""

    key_algorithm: Annotated[
        Optional[GetActiveCertificatesCertificatesResponse200KeyAlgorithm],
        pydantic.Field(alias="keyAlgorithm"),
    ] = None
    r"""The key algorithm of the certificate. This is either `ECDSA` or `RSA`."""

    serial: OptionalNullable[str] = UNSET
    r"""Serial number that uniquely identifies each certificate."""

    sha256_fingerprint: Annotated[
        Optional[str], pydantic.Field(alias="sha256Fingerprint")
    ] = None
    r"""A digital fingerprint, formatted as 32 pairs of hexadecimal digits separated by ':'."""

    signature_algorithm: Annotated[
        OptionalNullable[
            GetActiveCertificatesCertificatesResponse200SignatureAlgorithm
        ],
        pydantic.Field(alias="signatureAlgorithm"),
    ] = UNSET
    r"""Indicates the SHA (Secure Hash Algorithm) function. You can use either `SHA-1` for a 160-bit (20-byte) hash or `SHA-256` for a 256-bit (32-byte) hash."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "expiry",
            "issuer",
            "keyAlgorithm",
            "serial",
            "sha256Fingerprint",
            "signatureAlgorithm",
        ]
        nullable_fields = ["serial", "signatureAlgorithm"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetActiveCertificatesCertificatesGeography(str, Enum):
    r"""Specifies the type of network where you want to deploy your certificate.  Use `core` to deploy across most of the world except for specially licensed areas.  Use `china+core` to include China, or `russia+core` to include Russia. Any non-`core` deployment needs to be enabled on your contract based on approval from the Chinese or Russian governments."""

    CORE = "core"
    CHINA_PLUS_CORE = "china+core"
    RUSSIA_PLUS_CORE = "russia+core"


class GetActiveCertificatesCertificatesOcspStapling(str, Enum):
    r"""Indicates the OCSP stapling setting for the deployment. Use `on` to enable OCSP stapling, `off` to disable it, or `not-set` to ignore it."""

    ON = "on"
    OFF = "off"
    NOT_SET = "not-set"


class GetActiveCertificatesCertificatesSecureNetwork(str, Enum):
    r"""Identifies the type of deployment network. An `enhanced-tls` value means Akamai's more secure network with PCI compliance capability, while `standard-tls` means Akamai's standard secure network."""

    ENHANCED_TLS = "enhanced-tls"
    STANDARD_TLS = "standard-tls"


class GetActiveCertificatesCertificatesNetworkConfigurationTypedDict(TypedDict):
    r"""Network configuration properties."""

    disallowed_tls_versions: NotRequired[List[str]]
    r"""Disallowed TLS protocols."""
    dns_names: NotRequired[Nullable[List[str]]]
    r"""Names served by SNI-only enabled enrollments."""
    fips_mode: NotRequired[bool]
    r"""Enables Federal Information Processing Standards (FIPS) for the enrollment."""
    geography: NotRequired[GetActiveCertificatesCertificatesGeography]
    r"""Specifies the type of network where you want to deploy your certificate.  Use `core` to deploy across most of the world except for specially licensed areas.  Use `china+core` to include China, or `russia+core` to include Russia. Any non-`core` deployment needs to be enabled on your contract based on approval from the Chinese or Russian governments."""
    must_have_ciphers: NotRequired[str]
    r"""Ciphers that you definitely want to include for your enrollment while deploying it on the network. For more information on cipher profiles, see [Update SSL/TLS cipher profiles](doc:cipher-profiles)."""
    ocsp_stapling: NotRequired[GetActiveCertificatesCertificatesOcspStapling]
    r"""Indicates the OCSP stapling setting for the deployment. Use `on` to enable OCSP stapling, `off` to disable it, or `not-set` to ignore it."""
    preferred_ciphers: NotRequired[str]
    r"""Ciphers that you preferably want to include for your enrollment while deploying it on the network. For more information on cipher profiles, see [Update SSL/TLS cipher profiles](doc:cipher-profiles)."""
    quic_enabled: NotRequired[bool]
    r"""QUIC transport layer network protocol."""
    secure_network: NotRequired[GetActiveCertificatesCertificatesSecureNetwork]
    r"""Identifies the type of deployment network. An `enhanced-tls` value means Akamai's more secure network with PCI compliance capability, while `standard-tls` means Akamai's standard secure network."""
    sni_only: NotRequired[bool]
    r"""Server Name Indication (SNI) is an extension of the Transport Layer Security (TLS) networking protocol. It allows a server to present many certificates on the same IP address. All modern web browsers support the SNI extension. If you have the same SAN on two or more certificates with the SNI-only option set, Akamai may serve traffic using any certificate which matches the requested SNI hostname. You should avoid any certificates with overlapping SAN names when using SNI-only."""


class GetActiveCertificatesCertificatesNetworkConfiguration(BaseModel):
    r"""Network configuration properties."""

    disallowed_tls_versions: Annotated[
        Optional[List[str]], pydantic.Field(alias="disallowedTlsVersions")
    ] = None
    r"""Disallowed TLS protocols."""

    dns_names: Annotated[
        OptionalNullable[List[str]], pydantic.Field(alias="dnsNames")
    ] = UNSET
    r"""Names served by SNI-only enabled enrollments."""

    fips_mode: Annotated[Optional[bool], pydantic.Field(alias="fipsMode")] = None
    r"""Enables Federal Information Processing Standards (FIPS) for the enrollment."""

    geography: Optional[GetActiveCertificatesCertificatesGeography] = None
    r"""Specifies the type of network where you want to deploy your certificate.  Use `core` to deploy across most of the world except for specially licensed areas.  Use `china+core` to include China, or `russia+core` to include Russia. Any non-`core` deployment needs to be enabled on your contract based on approval from the Chinese or Russian governments."""

    must_have_ciphers: Annotated[
        Optional[str], pydantic.Field(alias="mustHaveCiphers")
    ] = None
    r"""Ciphers that you definitely want to include for your enrollment while deploying it on the network. For more information on cipher profiles, see [Update SSL/TLS cipher profiles](doc:cipher-profiles)."""

    ocsp_stapling: Annotated[
        Optional[GetActiveCertificatesCertificatesOcspStapling],
        pydantic.Field(alias="ocspStapling"),
    ] = None
    r"""Indicates the OCSP stapling setting for the deployment. Use `on` to enable OCSP stapling, `off` to disable it, or `not-set` to ignore it."""

    preferred_ciphers: Annotated[
        Optional[str], pydantic.Field(alias="preferredCiphers")
    ] = None
    r"""Ciphers that you preferably want to include for your enrollment while deploying it on the network. For more information on cipher profiles, see [Update SSL/TLS cipher profiles](doc:cipher-profiles)."""

    quic_enabled: Annotated[Optional[bool], pydantic.Field(alias="quicEnabled")] = None
    r"""QUIC transport layer network protocol."""

    secure_network: Annotated[
        Optional[GetActiveCertificatesCertificatesSecureNetwork],
        pydantic.Field(alias="secureNetwork"),
    ] = None
    r"""Identifies the type of deployment network. An `enhanced-tls` value means Akamai's more secure network with PCI compliance capability, while `standard-tls` means Akamai's standard secure network."""

    sni_only: Annotated[Optional[bool], pydantic.Field(alias="sniOnly")] = None
    r"""Server Name Indication (SNI) is an extension of the Transport Layer Security (TLS) networking protocol. It allows a server to present many certificates on the same IP address. All modern web browsers support the SNI extension. If you have the same SAN on two or more certificates with the SNI-only option set, Akamai may serve traffic using any certificate which matches the requested SNI hostname. You should avoid any certificates with overlapping SAN names when using SNI-only."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "disallowedTlsVersions",
            "dnsNames",
            "fipsMode",
            "geography",
            "mustHaveCiphers",
            "ocspStapling",
            "preferredCiphers",
            "quicEnabled",
            "secureNetwork",
            "sniOnly",
        ]
        nullable_fields = ["dnsNames"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetActiveCertificatesKeyAlgorithm(str, Enum):
    r"""The key algorithm of the certificate. This is either `ECDSA` or `RSA`."""

    ECDSA = "ECDSA"
    RSA = "RSA"


class GetActiveCertificatesSignatureAlgorithm(str, Enum):
    r"""Indicates the SHA (Secure Hash Algorithm) function. You can use either `SHA-1` for a 160-bit (20-byte) hash or `SHA-256` for a 256-bit (32-byte) hash."""

    SHA_1 = "SHA-1"
    SHA_256 = "SHA-256"


class GetActiveCertificatesCertificatesPrimaryCertificateTypedDict(TypedDict):
    r"""Primary certificate for Enrollment."""

    expiry: NotRequired[datetime]
    r"""The expiration date for the certificate."""
    issuer: NotRequired[str]
    r"""Entity that has verified the certificate's contents."""
    key_algorithm: NotRequired[GetActiveCertificatesKeyAlgorithm]
    r"""The key algorithm of the certificate. This is either `ECDSA` or `RSA`."""
    serial: NotRequired[Nullable[str]]
    r"""Serial number that uniquely identifies each certificate."""
    sha256_fingerprint: NotRequired[str]
    r"""A digital fingerprint, formatted as 32 pairs of hexadecimal digits separated by ':'."""
    signature_algorithm: NotRequired[Nullable[GetActiveCertificatesSignatureAlgorithm]]
    r"""Indicates the SHA (Secure Hash Algorithm) function. You can use either `SHA-1` for a 160-bit (20-byte) hash or `SHA-256` for a 256-bit (32-byte) hash."""


class GetActiveCertificatesCertificatesPrimaryCertificate(BaseModel):
    r"""Primary certificate for Enrollment."""

    expiry: Optional[datetime] = None
    r"""The expiration date for the certificate."""

    issuer: Optional[str] = None
    r"""Entity that has verified the certificate's contents."""

    key_algorithm: Annotated[
        Optional[GetActiveCertificatesKeyAlgorithm],
        pydantic.Field(alias="keyAlgorithm"),
    ] = None
    r"""The key algorithm of the certificate. This is either `ECDSA` or `RSA`."""

    serial: OptionalNullable[str] = UNSET
    r"""Serial number that uniquely identifies each certificate."""

    sha256_fingerprint: Annotated[
        Optional[str], pydantic.Field(alias="sha256Fingerprint")
    ] = None
    r"""A digital fingerprint, formatted as 32 pairs of hexadecimal digits separated by ':'."""

    signature_algorithm: Annotated[
        OptionalNullable[GetActiveCertificatesSignatureAlgorithm],
        pydantic.Field(alias="signatureAlgorithm"),
    ] = UNSET
    r"""Indicates the SHA (Secure Hash Algorithm) function. You can use either `SHA-1` for a 160-bit (20-byte) hash or `SHA-256` for a 256-bit (32-byte) hash."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "expiry",
            "issuer",
            "keyAlgorithm",
            "serial",
            "sha256Fingerprint",
            "signatureAlgorithm",
        ]
        nullable_fields = ["serial", "signatureAlgorithm"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetActiveCertificatesProductionTypedDict(TypedDict):
    r"""Production deployment information."""

    location: NotRequired[Nullable[str]]
    r"""The URL path where you can GET the production deployment."""
    multi_stacked_certificates: NotRequired[
        List[GetActiveCertificatesCertificatesMultiStackedCertificatesTypedDict]
    ]
    r"""Dual-stacked certificates today include an ECDSA certificate in addition to an RSA certificate. Deployment may include many dual-stacked certificates."""
    network_configuration: NotRequired[
        GetActiveCertificatesCertificatesNetworkConfigurationTypedDict
    ]
    r"""Network configuration properties."""
    primary_certificate: NotRequired[
        GetActiveCertificatesCertificatesPrimaryCertificateTypedDict
    ]
    r"""Primary certificate for Enrollment."""


class GetActiveCertificatesProduction(BaseModel):
    r"""Production deployment information."""

    location: OptionalNullable[str] = UNSET
    r"""The URL path where you can GET the production deployment."""

    multi_stacked_certificates: Annotated[
        Optional[List[GetActiveCertificatesCertificatesMultiStackedCertificates]],
        pydantic.Field(alias="multiStackedCertificates"),
    ] = None
    r"""Dual-stacked certificates today include an ECDSA certificate in addition to an RSA certificate. Deployment may include many dual-stacked certificates."""

    network_configuration: Annotated[
        Optional[GetActiveCertificatesCertificatesNetworkConfiguration],
        pydantic.Field(alias="networkConfiguration"),
    ] = None
    r"""Network configuration properties."""

    primary_certificate: Annotated[
        Optional[GetActiveCertificatesCertificatesPrimaryCertificate],
        pydantic.Field(alias="primaryCertificate"),
    ] = None
    r"""Primary certificate for Enrollment."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "location",
            "multiStackedCertificates",
            "networkConfiguration",
            "primaryCertificate",
        ]
        nullable_fields = ["location"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetActiveCertificatesCertificatesKeyAlgorithm(str, Enum):
    r"""The key algorithm of the certificate. This is either `ECDSA` or `RSA`."""

    ECDSA = "ECDSA"
    RSA = "RSA"


class GetActiveCertificatesCertificatesSignatureAlgorithm(str, Enum):
    r"""Indicates the SHA (Secure Hash Algorithm) function. You can use either `SHA-1` for a 160-bit (20-byte) hash or `SHA-256` for a 256-bit (32-byte) hash."""

    SHA_1 = "SHA-1"
    SHA_256 = "SHA-256"


class GetActiveCertificatesMultiStackedCertificatesTypedDict(TypedDict):
    expiry: NotRequired[str]
    r"""The expiration date for the certificate."""
    issuer: NotRequired[str]
    r"""Entity that has verified the certificate's contents."""
    key_algorithm: NotRequired[GetActiveCertificatesCertificatesKeyAlgorithm]
    r"""The key algorithm of the certificate. This is either `ECDSA` or `RSA`."""
    serial: NotRequired[Nullable[str]]
    r"""Serial number that uniquely identifies each certificate."""
    sha256_fingerprint: NotRequired[str]
    r"""A digital fingerprint, formatted as 32 pairs of hexadecimal digits separated by ':'."""
    signature_algorithm: NotRequired[
        Nullable[GetActiveCertificatesCertificatesSignatureAlgorithm]
    ]
    r"""Indicates the SHA (Secure Hash Algorithm) function. You can use either `SHA-1` for a 160-bit (20-byte) hash or `SHA-256` for a 256-bit (32-byte) hash."""


class GetActiveCertificatesMultiStackedCertificates(BaseModel):
    expiry: Optional[str] = None
    r"""The expiration date for the certificate."""

    issuer: Optional[str] = None
    r"""Entity that has verified the certificate's contents."""

    key_algorithm: Annotated[
        Optional[GetActiveCertificatesCertificatesKeyAlgorithm],
        pydantic.Field(alias="keyAlgorithm"),
    ] = None
    r"""The key algorithm of the certificate. This is either `ECDSA` or `RSA`."""

    serial: OptionalNullable[str] = UNSET
    r"""Serial number that uniquely identifies each certificate."""

    sha256_fingerprint: Annotated[
        Optional[str], pydantic.Field(alias="sha256Fingerprint")
    ] = None
    r"""A digital fingerprint, formatted as 32 pairs of hexadecimal digits separated by ':'."""

    signature_algorithm: Annotated[
        OptionalNullable[GetActiveCertificatesCertificatesSignatureAlgorithm],
        pydantic.Field(alias="signatureAlgorithm"),
    ] = UNSET
    r"""Indicates the SHA (Secure Hash Algorithm) function. You can use either `SHA-1` for a 160-bit (20-byte) hash or `SHA-256` for a 256-bit (32-byte) hash."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "expiry",
            "issuer",
            "keyAlgorithm",
            "serial",
            "sha256Fingerprint",
            "signatureAlgorithm",
        ]
        nullable_fields = ["serial", "signatureAlgorithm"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetActiveCertificatesGeography(str, Enum):
    r"""Specifies the type of network where you want to deploy your certificate.  Use `core` to deploy across most of the world except for specially licensed areas.  Use `china+core` to include China, or `russia+core` to include Russia. Any non-`core` deployment needs to be enabled on your contract based on approval from the Chinese or Russian governments."""

    CORE = "core"
    CHINA_PLUS_CORE = "china+core"
    RUSSIA_PLUS_CORE = "russia+core"


class GetActiveCertificatesOcspStapling(str, Enum):
    r"""Indicates the OCSP stapling setting for the deployment. Use `on` to enable OCSP stapling, `off` to disable it, or `not-set` to ignore it."""

    ON = "on"
    OFF = "off"
    NOT_SET = "not-set"


class GetActiveCertificatesSecureNetwork(str, Enum):
    r"""Identifies the type of deployment network. An `enhanced-tls` value means Akamai's more secure network with PCI compliance capability, while `standard-tls` means Akamai's standard secure network."""

    ENHANCED_TLS = "enhanced-tls"
    STANDARD_TLS = "standard-tls"


class GetActiveCertificatesNetworkConfigurationTypedDict(TypedDict):
    r"""Network configuration properties."""

    disallowed_tls_versions: NotRequired[List[str]]
    r"""Disallowed TLS protocols."""
    dns_names: NotRequired[Nullable[List[str]]]
    r"""Names served by SNI-only enabled enrollments."""
    fips_mode: NotRequired[bool]
    r"""Enables Federal Information Processing Standards (FIPS) for the enrollment."""
    geography: NotRequired[GetActiveCertificatesGeography]
    r"""Specifies the type of network where you want to deploy your certificate.  Use `core` to deploy across most of the world except for specially licensed areas.  Use `china+core` to include China, or `russia+core` to include Russia. Any non-`core` deployment needs to be enabled on your contract based on approval from the Chinese or Russian governments."""
    must_have_ciphers: NotRequired[str]
    r"""Ciphers that you definitely want to include for your enrollment while deploying it on the network. For more information on cipher profiles, see [Update SSL/TLS cipher profiles](doc:cipher-profiles)."""
    ocsp_stapling: NotRequired[GetActiveCertificatesOcspStapling]
    r"""Indicates the OCSP stapling setting for the deployment. Use `on` to enable OCSP stapling, `off` to disable it, or `not-set` to ignore it."""
    preferred_ciphers: NotRequired[str]
    r"""Ciphers that you preferably want to include for your enrollment while deploying it on the network. For more information on cipher profiles, see [Update SSL/TLS cipher profiles](doc:cipher-profiles)."""
    quic_enabled: NotRequired[bool]
    r"""QUIC transport layer network protocol."""
    secure_network: NotRequired[GetActiveCertificatesSecureNetwork]
    r"""Identifies the type of deployment network. An `enhanced-tls` value means Akamai's more secure network with PCI compliance capability, while `standard-tls` means Akamai's standard secure network."""
    sni_only: NotRequired[bool]
    r"""Server Name Indication (SNI) is an extension of the Transport Layer Security (TLS) networking protocol. It allows a server to present many certificates on the same IP address. All modern web browsers support the SNI extension. If you have the same SAN on two or more certificates with the SNI-only option set, Akamai may serve traffic using any certificate that matches the requested SNI hostname. You should avoid any certificates with overlapping SAN names when using SNI-only."""


class GetActiveCertificatesNetworkConfiguration(BaseModel):
    r"""Network configuration properties."""

    disallowed_tls_versions: Annotated[
        Optional[List[str]], pydantic.Field(alias="disallowedTlsVersions")
    ] = None
    r"""Disallowed TLS protocols."""

    dns_names: Annotated[
        OptionalNullable[List[str]], pydantic.Field(alias="dnsNames")
    ] = UNSET
    r"""Names served by SNI-only enabled enrollments."""

    fips_mode: Annotated[Optional[bool], pydantic.Field(alias="fipsMode")] = None
    r"""Enables Federal Information Processing Standards (FIPS) for the enrollment."""

    geography: Optional[GetActiveCertificatesGeography] = None
    r"""Specifies the type of network where you want to deploy your certificate.  Use `core` to deploy across most of the world except for specially licensed areas.  Use `china+core` to include China, or `russia+core` to include Russia. Any non-`core` deployment needs to be enabled on your contract based on approval from the Chinese or Russian governments."""

    must_have_ciphers: Annotated[
        Optional[str], pydantic.Field(alias="mustHaveCiphers")
    ] = None
    r"""Ciphers that you definitely want to include for your enrollment while deploying it on the network. For more information on cipher profiles, see [Update SSL/TLS cipher profiles](doc:cipher-profiles)."""

    ocsp_stapling: Annotated[
        Optional[GetActiveCertificatesOcspStapling],
        pydantic.Field(alias="ocspStapling"),
    ] = None
    r"""Indicates the OCSP stapling setting for the deployment. Use `on` to enable OCSP stapling, `off` to disable it, or `not-set` to ignore it."""

    preferred_ciphers: Annotated[
        Optional[str], pydantic.Field(alias="preferredCiphers")
    ] = None
    r"""Ciphers that you preferably want to include for your enrollment while deploying it on the network. For more information on cipher profiles, see [Update SSL/TLS cipher profiles](doc:cipher-profiles)."""

    quic_enabled: Annotated[Optional[bool], pydantic.Field(alias="quicEnabled")] = None
    r"""QUIC transport layer network protocol."""

    secure_network: Annotated[
        Optional[GetActiveCertificatesSecureNetwork],
        pydantic.Field(alias="secureNetwork"),
    ] = None
    r"""Identifies the type of deployment network. An `enhanced-tls` value means Akamai's more secure network with PCI compliance capability, while `standard-tls` means Akamai's standard secure network."""

    sni_only: Annotated[Optional[bool], pydantic.Field(alias="sniOnly")] = None
    r"""Server Name Indication (SNI) is an extension of the Transport Layer Security (TLS) networking protocol. It allows a server to present many certificates on the same IP address. All modern web browsers support the SNI extension. If you have the same SAN on two or more certificates with the SNI-only option set, Akamai may serve traffic using any certificate that matches the requested SNI hostname. You should avoid any certificates with overlapping SAN names when using SNI-only."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "disallowedTlsVersions",
            "dnsNames",
            "fipsMode",
            "geography",
            "mustHaveCiphers",
            "ocspStapling",
            "preferredCiphers",
            "quicEnabled",
            "secureNetwork",
            "sniOnly",
        ]
        nullable_fields = ["dnsNames"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetActiveCertificatesCertificatesResponseKeyAlgorithm(str, Enum):
    r"""The key algorithm of the certificate. This is either `ECDSA` or `RSA`."""

    ECDSA = "ECDSA"
    RSA = "RSA"


class GetActiveCertificatesCertificatesResponseSignatureAlgorithm(str, Enum):
    r"""Indicates the SHA (Secure Hash Algorithm) function. You can use either `SHA-1` for a 160-bit (20-byte) hash or `SHA-256` for a 256-bit (32-byte) hash."""

    SHA_1 = "SHA-1"
    SHA_256 = "SHA-256"


class GetActiveCertificatesPrimaryCertificateTypedDict(TypedDict):
    r"""Primary certificate for the enrollment."""

    expiry: NotRequired[str]
    r"""The expiration date for the certificate."""
    issuer: NotRequired[str]
    r"""Entity that has verified the certificate's contents."""
    key_algorithm: NotRequired[GetActiveCertificatesCertificatesResponseKeyAlgorithm]
    r"""The key algorithm of the certificate. This is either `ECDSA` or `RSA`."""
    serial: NotRequired[Nullable[str]]
    r"""Serial number that uniquely identifies each certificate."""
    sha256_fingerprint: NotRequired[str]
    r"""A digital fingerprint, formatted as 32 pairs of hexadecimal digits separated by ':'."""
    signature_algorithm: NotRequired[
        Nullable[GetActiveCertificatesCertificatesResponseSignatureAlgorithm]
    ]
    r"""Indicates the SHA (Secure Hash Algorithm) function. You can use either `SHA-1` for a 160-bit (20-byte) hash or `SHA-256` for a 256-bit (32-byte) hash."""


class GetActiveCertificatesPrimaryCertificate(BaseModel):
    r"""Primary certificate for the enrollment."""

    expiry: Optional[str] = None
    r"""The expiration date for the certificate."""

    issuer: Optional[str] = None
    r"""Entity that has verified the certificate's contents."""

    key_algorithm: Annotated[
        Optional[GetActiveCertificatesCertificatesResponseKeyAlgorithm],
        pydantic.Field(alias="keyAlgorithm"),
    ] = None
    r"""The key algorithm of the certificate. This is either `ECDSA` or `RSA`."""

    serial: OptionalNullable[str] = UNSET
    r"""Serial number that uniquely identifies each certificate."""

    sha256_fingerprint: Annotated[
        Optional[str], pydantic.Field(alias="sha256Fingerprint")
    ] = None
    r"""A digital fingerprint, formatted as 32 pairs of hexadecimal digits separated by ':'."""

    signature_algorithm: Annotated[
        OptionalNullable[GetActiveCertificatesCertificatesResponseSignatureAlgorithm],
        pydantic.Field(alias="signatureAlgorithm"),
    ] = UNSET
    r"""Indicates the SHA (Secure Hash Algorithm) function. You can use either `SHA-1` for a 160-bit (20-byte) hash or `SHA-256` for a 256-bit (32-byte) hash."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "expiry",
            "issuer",
            "keyAlgorithm",
            "serial",
            "sha256Fingerprint",
            "signatureAlgorithm",
        ]
        nullable_fields = ["serial", "signatureAlgorithm"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetActiveCertificatesStagingTypedDict(TypedDict):
    r"""Staging deployment information."""

    location: NotRequired[Nullable[str]]
    r"""The URL path where you can GET the staging deployment."""
    multi_stacked_certificates: NotRequired[
        List[GetActiveCertificatesMultiStackedCertificatesTypedDict]
    ]
    r"""Dual-stacked certificates today include an ECDSA certificate in addition to an RSA certificate. Deployments may include many dual-stacked certificates."""
    network_configuration: NotRequired[
        GetActiveCertificatesNetworkConfigurationTypedDict
    ]
    r"""Network configuration properties."""
    primary_certificate: NotRequired[GetActiveCertificatesPrimaryCertificateTypedDict]
    r"""Primary certificate for the enrollment."""


class GetActiveCertificatesStaging(BaseModel):
    r"""Staging deployment information."""

    location: OptionalNullable[str] = UNSET
    r"""The URL path where you can GET the staging deployment."""

    multi_stacked_certificates: Annotated[
        Optional[List[GetActiveCertificatesMultiStackedCertificates]],
        pydantic.Field(alias="multiStackedCertificates"),
    ] = None
    r"""Dual-stacked certificates today include an ECDSA certificate in addition to an RSA certificate. Deployments may include many dual-stacked certificates."""

    network_configuration: Annotated[
        Optional[GetActiveCertificatesNetworkConfiguration],
        pydantic.Field(alias="networkConfiguration"),
    ] = None
    r"""Network configuration properties."""

    primary_certificate: Annotated[
        Optional[GetActiveCertificatesPrimaryCertificate],
        pydantic.Field(alias="primaryCertificate"),
    ] = None
    r"""Primary certificate for the enrollment."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "location",
            "multiStackedCertificates",
            "networkConfiguration",
            "primaryCertificate",
        ]
        nullable_fields = ["location"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetActiveCertificatesEnrollmentsTypedDict(TypedDict):
    r"""An enrollment with the information about your certificates. CPS is a certificate life cycle management tool. Once you obtain a certificate, you use it until it expires, in most cases a year from the date the CA issued the certificate. CPS automatically starts the renewal process 90 days before the old certificate expires. It then automatically deploys the renewed certificate when it receives it from the CA."""

    assigned_slots: NotRequired[Nullable[List[int]]]
    r"""Slots where the certificate is either deployed or about to deploy."""
    certificate_type: NotRequired[GetActiveCertificatesCertificateType]
    r"""Specifies the kind of certificate in the enrollment. Either `san`, `single`, `wildcard`, `wildcard-san`, or `third-party`. For details, see `validationType` in the [Enrollment object's versioned schema members](ref:enrollment#versioned-schema-members)."""
    csr: NotRequired[GetActiveCertificatesCsrTypedDict]
    r"""When you create an enrollment, CPS also generates a certificate signing request (CSR). CPS signs the CSR with the private key. The CSR contains all the information the CA needs to issue your certificate."""
    enable_multi_stacked_certificates: NotRequired[bool]
    r"""Enable dual-stacked certificate deployment for this enrollment. The next renewal includes the change. Note that this value only appears for third-party certificates."""
    id: NotRequired[int]
    r"""The unique identifier of the enrollment."""
    location: NotRequired[Nullable[str]]
    r"""The URL path where you can GET the enrollment."""
    pending_changes: NotRequired[
        Nullable[List[GetActiveCertificatesPendingChangesTypedDict]]
    ]
    r"""Currently pending changes. The last item in the array is the most recent change."""
    production: NotRequired[GetActiveCertificatesProductionTypedDict]
    r"""Production deployment information."""
    production_slots: NotRequired[Nullable[List[int]]]
    r"""Slots where the certificate is deployed on the production network."""
    staging: NotRequired[GetActiveCertificatesStagingTypedDict]
    r"""Staging deployment information."""
    staging_slots: NotRequired[Nullable[List[int]]]
    r"""Slots where the certificate deploys on the staging network."""


class GetActiveCertificatesEnrollments(BaseModel):
    r"""An enrollment with the information about your certificates. CPS is a certificate life cycle management tool. Once you obtain a certificate, you use it until it expires, in most cases a year from the date the CA issued the certificate. CPS automatically starts the renewal process 90 days before the old certificate expires. It then automatically deploys the renewed certificate when it receives it from the CA."""

    assigned_slots: Annotated[
        OptionalNullable[List[int]], pydantic.Field(alias="assignedSlots")
    ] = UNSET
    r"""Slots where the certificate is either deployed or about to deploy."""

    certificate_type: Annotated[
        Optional[GetActiveCertificatesCertificateType],
        pydantic.Field(alias="certificateType"),
    ] = None
    r"""Specifies the kind of certificate in the enrollment. Either `san`, `single`, `wildcard`, `wildcard-san`, or `third-party`. For details, see `validationType` in the [Enrollment object's versioned schema members](ref:enrollment#versioned-schema-members)."""

    csr: Optional[GetActiveCertificatesCsr] = None
    r"""When you create an enrollment, CPS also generates a certificate signing request (CSR). CPS signs the CSR with the private key. The CSR contains all the information the CA needs to issue your certificate."""

    enable_multi_stacked_certificates: Annotated[
        Optional[bool], pydantic.Field(alias="enableMultiStackedCertificates")
    ] = None
    r"""Enable dual-stacked certificate deployment for this enrollment. The next renewal includes the change. Note that this value only appears for third-party certificates."""

    id: Optional[int] = None
    r"""The unique identifier of the enrollment."""

    location: OptionalNullable[str] = UNSET
    r"""The URL path where you can GET the enrollment."""

    pending_changes: Annotated[
        OptionalNullable[List[GetActiveCertificatesPendingChanges]],
        pydantic.Field(alias="pendingChanges"),
    ] = UNSET
    r"""Currently pending changes. The last item in the array is the most recent change."""

    production: Optional[GetActiveCertificatesProduction] = None
    r"""Production deployment information."""

    production_slots: Annotated[
        OptionalNullable[List[int]], pydantic.Field(alias="productionSlots")
    ] = UNSET
    r"""Slots where the certificate is deployed on the production network."""

    staging: Optional[GetActiveCertificatesStaging] = None
    r"""Staging deployment information."""

    staging_slots: Annotated[
        OptionalNullable[List[int]], pydantic.Field(alias="stagingSlots")
    ] = UNSET
    r"""Slots where the certificate deploys on the staging network."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "assignedSlots",
            "certificateType",
            "csr",
            "enableMultiStackedCertificates",
            "id",
            "location",
            "pendingChanges",
            "production",
            "productionSlots",
            "staging",
            "stagingSlots",
        ]
        nullable_fields = [
            "assignedSlots",
            "location",
            "pendingChanges",
            "productionSlots",
            "stagingSlots",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetActiveCertificatesResponseBodyTypedDict(TypedDict):
    r"""Lists enrollments with details on active certificates."""

    enrollments: List[GetActiveCertificatesEnrollmentsTypedDict]
    r"""Enrollments with active certificates."""


class GetActiveCertificatesResponseBody(BaseModel):
    r"""Lists enrollments with details on active certificates."""

    enrollments: List[GetActiveCertificatesEnrollments]
    r"""Enrollments with active certificates."""
