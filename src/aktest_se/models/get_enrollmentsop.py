"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from aktest_se.types import BaseModel, Nullable, OptionalNullable, UNSET, UNSET_SENTINEL
from aktest_se.utils import FieldMetadata, QueryParamMetadata
from enum import Enum
import pydantic
from pydantic import model_serializer
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class GetEnrollmentsRequestTypedDict(TypedDict):
    contract_id: str
    r"""Specify the contract on which to operate or view."""
    account_switch_key: NotRequired[str]
    r"""For customers who manage more than one account, this [runs the operation from another account](https://techdocs.akamai.com/developer/docs/manage-many-accounts-with-one-api-client). The Identity and Access Management API provides a [list of available account switch keys](https://techdocs.akamai.com/iam-api/reference/get-client-account-switch-keys)."""


class GetEnrollmentsRequest(BaseModel):
    contract_id: Annotated[
        str,
        pydantic.Field(alias="contractId"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ]
    r"""Specify the contract on which to operate or view."""

    account_switch_key: Annotated[
        Optional[str],
        pydantic.Field(alias="accountSwitchKey"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""For customers who manage more than one account, this [runs the operation from another account](https://techdocs.akamai.com/developer/docs/manage-many-accounts-with-one-api-client). The Identity and Access Management API provides a [list of available account switch keys](https://techdocs.akamai.com/iam-api/reference/get-client-account-switch-keys)."""


class GetEnrollmentsAdminContactTypedDict(TypedDict):
    r"""Contact information for the certificate administrator that you want to use as a contact at your company."""

    address_line_one: Nullable[str]
    r"""The address of your organization."""
    address_line_two: Nullable[str]
    r"""The address of your organization."""
    city: Nullable[str]
    r"""The city where your organization resides."""
    country: Nullable[str]
    r"""The country where your organization resides."""
    email: Nullable[str]
    r"""The email address of the administrator who you want to use as a contact at your company."""
    first_name: Nullable[str]
    r"""The first name of the administrator who you want to use as a contact at your company."""
    last_name: Nullable[str]
    r"""The last name of the administrator who you want to use as a contact at your company."""
    organization_name: Nullable[str]
    r"""The name of your organization."""
    phone: Nullable[str]
    r"""The phone number of your organization."""
    postal_code: Nullable[str]
    r"""The postal code of your organization."""
    region: Nullable[str]
    r"""The region of your organization, typically a state or province."""
    title: Nullable[str]
    r"""The title of the administrator who you want to use as a contact at your company."""


class GetEnrollmentsAdminContact(BaseModel):
    r"""Contact information for the certificate administrator that you want to use as a contact at your company."""

    address_line_one: Annotated[Nullable[str], pydantic.Field(alias="addressLineOne")]
    r"""The address of your organization."""

    address_line_two: Annotated[Nullable[str], pydantic.Field(alias="addressLineTwo")]
    r"""The address of your organization."""

    city: Nullable[str]
    r"""The city where your organization resides."""

    country: Nullable[str]
    r"""The country where your organization resides."""

    email: Nullable[str]
    r"""The email address of the administrator who you want to use as a contact at your company."""

    first_name: Annotated[Nullable[str], pydantic.Field(alias="firstName")]
    r"""The first name of the administrator who you want to use as a contact at your company."""

    last_name: Annotated[Nullable[str], pydantic.Field(alias="lastName")]
    r"""The last name of the administrator who you want to use as a contact at your company."""

    organization_name: Annotated[
        Nullable[str], pydantic.Field(alias="organizationName")
    ]
    r"""The name of your organization."""

    phone: Nullable[str]
    r"""The phone number of your organization."""

    postal_code: Annotated[Nullable[str], pydantic.Field(alias="postalCode")]
    r"""The postal code of your organization."""

    region: Nullable[str]
    r"""The region of your organization, typically a state or province."""

    title: Nullable[str]
    r"""The title of the administrator who you want to use as a contact at your company."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = [
            "addressLineOne",
            "addressLineTwo",
            "city",
            "country",
            "email",
            "firstName",
            "lastName",
            "organizationName",
            "phone",
            "postalCode",
            "region",
            "title",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetEnrollmentsCertificateChainType(str, Enum):
    r"""The kind of certificate trust chain. This is either `default` or `symantec1kroot`."""

    DEFAULT = "default"
    SYMANTEC1KROOT = "symantec1kroot"


class GetEnrollmentsCertificateType(str, Enum):
    r"""Specifies the kind of certificate in the enrollment. Either san`, `single`, `wildcard`, `wildcard-san`, or `third-party. For details, see `validationType` in the [Enrollment object's versioned schema members](ref:enrollment#versioned-schema-members)."""

    SAN = "san"
    SINGLE = "single"
    WILDCARD = "wildcard"
    WILDCARD_SAN = "wildcard-san"
    THIRD_PARTY = "third-party"


class GetEnrollmentsCsrTypedDict(TypedDict):
    r"""When you create an enrollment, you also generate a certificate signing request (CSR) using CPS. CPS signs the CSR with the private key. The CSR contains all the information the CA needs to issue your certificate."""

    cn: str
    r"""The domain name to use for the certificate, also known as the _common name_. Note that the organization specified as the `o` needs to own or have legal rights to this domain name."""
    c: NotRequired[Nullable[str]]
    r"""The country code for the country where your organization is located."""
    l: NotRequired[Nullable[str]]
    r"""Your city in the locality (city)."""
    o: NotRequired[Nullable[str]]
    r"""The name of your company or organization. Enter the name as it appears in all legal documents and as it appears in the legal entity filing."""
    ou: NotRequired[Nullable[str]]
    r"""Your organizational unit."""
    preferred_trust_chain: NotRequired[Nullable[str]]
    r"""For the Let's Encrypt Domain Validated (DV) SAN certificates, a preferred trust chain isn't needed. The default value is `null`."""
    sans: NotRequired[Nullable[List[str]]]
    r"""Additional `cn` values to create a Subject Alternative Names (SAN) list. If there are no SANs, the response shows an empty list. Removing a SAN list from an enrollment may disrupt your service for TLS connections."""
    st: NotRequired[Nullable[str]]
    r"""Your state or province."""


class GetEnrollmentsCsr(BaseModel):
    r"""When you create an enrollment, you also generate a certificate signing request (CSR) using CPS. CPS signs the CSR with the private key. The CSR contains all the information the CA needs to issue your certificate."""

    cn: str
    r"""The domain name to use for the certificate, also known as the _common name_. Note that the organization specified as the `o` needs to own or have legal rights to this domain name."""

    c: OptionalNullable[str] = UNSET
    r"""The country code for the country where your organization is located."""

    l: OptionalNullable[str] = UNSET
    r"""Your city in the locality (city)."""

    o: OptionalNullable[str] = UNSET
    r"""The name of your company or organization. Enter the name as it appears in all legal documents and as it appears in the legal entity filing."""

    ou: OptionalNullable[str] = UNSET
    r"""Your organizational unit."""

    preferred_trust_chain: Annotated[
        OptionalNullable[str], pydantic.Field(alias="preferredTrustChain")
    ] = UNSET
    r"""For the Let's Encrypt Domain Validated (DV) SAN certificates, a preferred trust chain isn't needed. The default value is `null`."""

    sans: OptionalNullable[List[str]] = UNSET
    r"""Additional `cn` values to create a Subject Alternative Names (SAN) list. If there are no SANs, the response shows an empty list. Removing a SAN list from an enrollment may disrupt your service for TLS connections."""

    st: OptionalNullable[str] = UNSET
    r"""Your state or province."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["c", "l", "o", "ou", "preferredTrustChain", "sans", "st"]
        nullable_fields = ["c", "l", "o", "ou", "preferredTrustChain", "sans", "st"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetEnrollmentsOcspTypedDict(TypedDict):
    r"""Whether you want to enable OCSP stapling for client certificates."""

    enabled: Nullable[bool]
    r"""Whether the OCSP stapling is enabled."""


class GetEnrollmentsOcsp(BaseModel):
    r"""Whether you want to enable OCSP stapling for client certificates."""

    enabled: Nullable[bool]
    r"""Whether the OCSP stapling is enabled."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["enabled"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetEnrollmentsAuthenticationOptionsTypedDict(TypedDict):
    r"""Contains the configuration options for the selected trust chain."""

    ocsp: Nullable[GetEnrollmentsOcspTypedDict]
    r"""Whether you want to enable OCSP stapling for client certificates."""
    send_ca_list_to_client: Nullable[bool]
    r"""Whether you want to enable the server to send the certificate authority (CA) list to the client."""


class GetEnrollmentsAuthenticationOptions(BaseModel):
    r"""Contains the configuration options for the selected trust chain."""

    ocsp: Nullable[GetEnrollmentsOcsp]
    r"""Whether you want to enable OCSP stapling for client certificates."""

    send_ca_list_to_client: Annotated[
        Nullable[bool], pydantic.Field(alias="sendCaListToClient")
    ]
    r"""Whether you want to enable the server to send the certificate authority (CA) list to the client."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["ocsp", "sendCaListToClient"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetEnrollmentsClientMutualAuthenticationTypedDict(TypedDict):
    r"""The configuration for client mutual authentication. Specifies the trust chain that verifies client certificates and some configuration options."""

    authentication_options: Nullable[GetEnrollmentsAuthenticationOptionsTypedDict]
    r"""Contains the configuration options for the selected trust chain."""
    set_id: NotRequired[Nullable[str]]
    r"""The identifier of the set of trust chains, created in the [Mutual TLS Edge Truststore](https://techdocs.akamai.com/mtls-edge-truststore/docs)."""


class GetEnrollmentsClientMutualAuthentication(BaseModel):
    r"""The configuration for client mutual authentication. Specifies the trust chain that verifies client certificates and some configuration options."""

    authentication_options: Annotated[
        Nullable[GetEnrollmentsAuthenticationOptions],
        pydantic.Field(alias="authenticationOptions"),
    ]
    r"""Contains the configuration options for the selected trust chain."""

    set_id: Annotated[OptionalNullable[str], pydantic.Field(alias="setId")] = UNSET
    r"""The identifier of the set of trust chains, created in the [Mutual TLS Edge Truststore](https://techdocs.akamai.com/mtls-edge-truststore/docs)."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["setId"]
        nullable_fields = ["authenticationOptions", "setId"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetEnrollmentsDNSNameSettingsTypedDict(TypedDict):
    r"""DNS name settings."""

    clone_dns_names: bool
    r"""Enable if you want CPS to direct traffic using all the SANs listed in the SANs parameter when you created your enrollment."""
    dns_names: NotRequired[Nullable[List[str]]]
    r"""Names served by SNI-only enabled enrollments."""


class GetEnrollmentsDNSNameSettings(BaseModel):
    r"""DNS name settings."""

    clone_dns_names: Annotated[bool, pydantic.Field(alias="cloneDnsNames")]
    r"""Enable if you want CPS to direct traffic using all the SANs listed in the SANs parameter when you created your enrollment."""

    dns_names: Annotated[
        OptionalNullable[List[str]], pydantic.Field(alias="dnsNames")
    ] = UNSET
    r"""Names served by SNI-only enabled enrollments."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["dnsNames"]
        nullable_fields = ["dnsNames"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetEnrollmentsGeography(str, Enum):
    r"""Specifies the type of network where you want to deploy your certificate.  Use `core` to deploy across most of the world except for specially licensed areas.  Use `china+core` to include China, or `russia+core` to include Russia. Any non-`core` deployment needs to be enabled on your contract based on approval from the Chinese or Russian governments."""

    CORE = "core"
    CHINA_PLUS_CORE = "china+core"
    RUSSIA_PLUS_CORE = "russia+core"


class GetEnrollmentsOcspStapling(str, Enum):
    r"""Enable OCSP stapling for the enrollment. OCSP Stapling improves performance by including a valid OCSP response in every TLS handshake. Specify OCSP Stapling if you want to improve performance by allowing your site's visitors to query the Online Certificate Status Protocol (OCSP) server at regular intervals to obtain a signed time-stamped OCSP response. This response needs to be signed by the CA, not the server, therefore ensuring security. Disable OSCP Stapling if you want your site's visitors to contact the CA directly for an OSCP response. You can use OCSP to obtain a certificate's revocation status. You should enable this feature. Use `on` to enable OSCP Stapling, `off` to disable it, or `not-set` to ignore it."""

    ON = "on"
    OFF = "off"
    NOT_SET = "not-set"


class GetEnrollmentsSecureNetwork(str, Enum):
    r"""Identifies the type of deployment network. `enhanced-tls` means Akamai's more secure network with PCI compliance capability, while `standard-tls` means Akamai's standard secure network."""

    ENHANCED_TLS = "enhanced-tls"
    STANDARD_TLS = "standard-tls"


class GetEnrollmentsNetworkConfigurationTypedDict(TypedDict):
    r"""Settings that specify any network information and TLS Metadata you want CPS to use to push the completed certificate to the network."""

    geography: GetEnrollmentsGeography
    r"""Specifies the type of network where you want to deploy your certificate.  Use `core` to deploy across most of the world except for specially licensed areas.  Use `china+core` to include China, or `russia+core` to include Russia. Any non-`core` deployment needs to be enabled on your contract based on approval from the Chinese or Russian governments."""
    quic_enabled: bool
    r"""Set to `true` to enable QUIC protocol."""
    secure_network: GetEnrollmentsSecureNetwork
    r"""Identifies the type of deployment network. `enhanced-tls` means Akamai's more secure network with PCI compliance capability, while `standard-tls` means Akamai's standard secure network."""
    sni_only: bool
    r"""SNI settings for your enrollment. Set to `true` to enable SNI-only for the enrollment. This setting cannot be changed once an enrollment is created."""
    client_mutual_authentication: NotRequired[
        Nullable[GetEnrollmentsClientMutualAuthenticationTypedDict]
    ]
    r"""The configuration for client mutual authentication. Specifies the trust chain that verifies client certificates and some configuration options."""
    disallowed_tls_versions: NotRequired[Nullable[List[str]]]
    r"""Specify the TLS protocol versions you want to disallow."""
    dns_name_settings: NotRequired[Nullable[GetEnrollmentsDNSNameSettingsTypedDict]]
    r"""DNS name settings."""
    must_have_ciphers: NotRequired[Nullable[str]]
    r"""Ciphers that you definitely want to include for your enrollment while deploying it on the network. Defaults to `ak-akamai-default` when it is not set."""
    ocsp_stapling: NotRequired[Nullable[GetEnrollmentsOcspStapling]]
    r"""Enable OCSP stapling for the enrollment. OCSP Stapling improves performance by including a valid OCSP response in every TLS handshake. Specify OCSP Stapling if you want to improve performance by allowing your site's visitors to query the Online Certificate Status Protocol (OCSP) server at regular intervals to obtain a signed time-stamped OCSP response. This response needs to be signed by the CA, not the server, therefore ensuring security. Disable OSCP Stapling if you want your site's visitors to contact the CA directly for an OSCP response. You can use OCSP to obtain a certificate's revocation status. You should enable this feature. Use `on` to enable OSCP Stapling, `off` to disable it, or `not-set` to ignore it."""
    preferred_ciphers: NotRequired[Nullable[str]]
    r"""Ciphers that you preferably want to include for your enrollment while deploying it on the network. Defaults to `ak-akamai-default` when it is not set."""


class GetEnrollmentsNetworkConfiguration(BaseModel):
    r"""Settings that specify any network information and TLS Metadata you want CPS to use to push the completed certificate to the network."""

    geography: GetEnrollmentsGeography
    r"""Specifies the type of network where you want to deploy your certificate.  Use `core` to deploy across most of the world except for specially licensed areas.  Use `china+core` to include China, or `russia+core` to include Russia. Any non-`core` deployment needs to be enabled on your contract based on approval from the Chinese or Russian governments."""

    quic_enabled: Annotated[bool, pydantic.Field(alias="quicEnabled")]
    r"""Set to `true` to enable QUIC protocol."""

    secure_network: Annotated[
        GetEnrollmentsSecureNetwork, pydantic.Field(alias="secureNetwork")
    ]
    r"""Identifies the type of deployment network. `enhanced-tls` means Akamai's more secure network with PCI compliance capability, while `standard-tls` means Akamai's standard secure network."""

    sni_only: Annotated[bool, pydantic.Field(alias="sniOnly")]
    r"""SNI settings for your enrollment. Set to `true` to enable SNI-only for the enrollment. This setting cannot be changed once an enrollment is created."""

    client_mutual_authentication: Annotated[
        OptionalNullable[GetEnrollmentsClientMutualAuthentication],
        pydantic.Field(alias="clientMutualAuthentication"),
    ] = UNSET
    r"""The configuration for client mutual authentication. Specifies the trust chain that verifies client certificates and some configuration options."""

    disallowed_tls_versions: Annotated[
        OptionalNullable[List[str]], pydantic.Field(alias="disallowedTlsVersions")
    ] = UNSET
    r"""Specify the TLS protocol versions you want to disallow."""

    dns_name_settings: Annotated[
        OptionalNullable[GetEnrollmentsDNSNameSettings],
        pydantic.Field(alias="dnsNameSettings"),
    ] = UNSET
    r"""DNS name settings."""

    must_have_ciphers: Annotated[
        OptionalNullable[str], pydantic.Field(alias="mustHaveCiphers")
    ] = UNSET
    r"""Ciphers that you definitely want to include for your enrollment while deploying it on the network. Defaults to `ak-akamai-default` when it is not set."""

    ocsp_stapling: Annotated[
        OptionalNullable[GetEnrollmentsOcspStapling],
        pydantic.Field(alias="ocspStapling"),
    ] = UNSET
    r"""Enable OCSP stapling for the enrollment. OCSP Stapling improves performance by including a valid OCSP response in every TLS handshake. Specify OCSP Stapling if you want to improve performance by allowing your site's visitors to query the Online Certificate Status Protocol (OCSP) server at regular intervals to obtain a signed time-stamped OCSP response. This response needs to be signed by the CA, not the server, therefore ensuring security. Disable OSCP Stapling if you want your site's visitors to contact the CA directly for an OSCP response. You can use OCSP to obtain a certificate's revocation status. You should enable this feature. Use `on` to enable OSCP Stapling, `off` to disable it, or `not-set` to ignore it."""

    preferred_ciphers: Annotated[
        OptionalNullable[str], pydantic.Field(alias="preferredCiphers")
    ] = UNSET
    r"""Ciphers that you preferably want to include for your enrollment while deploying it on the network. Defaults to `ak-akamai-default` when it is not set."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "clientMutualAuthentication",
            "disallowedTlsVersions",
            "dnsNameSettings",
            "mustHaveCiphers",
            "ocspStapling",
            "preferredCiphers",
        ]
        nullable_fields = [
            "clientMutualAuthentication",
            "disallowedTlsVersions",
            "dnsNameSettings",
            "mustHaveCiphers",
            "ocspStapling",
            "preferredCiphers",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetEnrollmentsOrgTypedDict(TypedDict):
    r"""Your organization information."""

    address_line_one: Nullable[str]
    r"""The address of your organization."""
    address_line_two: Nullable[str]
    r"""The address of your organization."""
    city: Nullable[str]
    r"""The city where your organization resides."""
    country: Nullable[str]
    r"""The country where your organization resides."""
    name: Nullable[str]
    r"""The name of your organization."""
    phone: Nullable[str]
    r"""The phone number of the administrator who you want to use as a contact at your company."""
    postal_code: Nullable[str]
    r"""The postal code of your organization."""
    region: Nullable[str]
    r"""The region where your organization resides."""


class GetEnrollmentsOrg(BaseModel):
    r"""Your organization information."""

    address_line_one: Annotated[Nullable[str], pydantic.Field(alias="addressLineOne")]
    r"""The address of your organization."""

    address_line_two: Annotated[Nullable[str], pydantic.Field(alias="addressLineTwo")]
    r"""The address of your organization."""

    city: Nullable[str]
    r"""The city where your organization resides."""

    country: Nullable[str]
    r"""The country where your organization resides."""

    name: Nullable[str]
    r"""The name of your organization."""

    phone: Nullable[str]
    r"""The phone number of the administrator who you want to use as a contact at your company."""

    postal_code: Annotated[Nullable[str], pydantic.Field(alias="postalCode")]
    r"""The postal code of your organization."""

    region: Nullable[str]
    r"""The region where your organization resides."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = [
            "addressLineOne",
            "addressLineTwo",
            "city",
            "country",
            "name",
            "phone",
            "postalCode",
            "region",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetEnrollmentsChangeType(str, Enum):
    r"""Indicates the certificate's pending change action. This is either `new-certificate`, `modify-certificate`, `modify-san`, or `renewal`."""

    NEW_CERTIFICATE = "new-certificate"
    MODIFY_CERTIFICATE = "modify-certificate"
    MODIFY_SAN = "modify-san"
    RENEWAL = "renewal"


class GetEnrollmentsPendingChangesTypedDict(TypedDict):
    location: str
    r"""Location to fetch related change information."""
    change_type: NotRequired[Nullable[GetEnrollmentsChangeType]]
    r"""Indicates the certificate's pending change action. This is either `new-certificate`, `modify-certificate`, `modify-san`, or `renewal`."""


class GetEnrollmentsPendingChanges(BaseModel):
    location: str
    r"""Location to fetch related change information."""

    change_type: Annotated[
        OptionalNullable[GetEnrollmentsChangeType], pydantic.Field(alias="changeType")
    ] = UNSET
    r"""Indicates the certificate's pending change action. This is either `new-certificate`, `modify-certificate`, `modify-san`, or `renewal`."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["changeType"]
        nullable_fields = ["changeType"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetEnrollmentsRa(str, Enum):
    r"""The registration authority or certificate authority (CA) you want to use to obtain a certificate. A CA is a trusted entity that signs certificates and can vouch for the identity of a website. This is either `symantec`,  `lets-encrypt`, or `third-party`."""

    SYMANTEC = "symantec"
    LETS_ENCRYPT = "lets-encrypt"
    THIRD_PARTY = "third-party"


class GetEnrollmentsSignatureAlgorithm(str, Enum):
    r"""Identifies the SHA (Secure Hash Algorithm) function. The NSA (National Security Agency) designed this function to produce a hash of certificate contents, for use in a digital signature. This is either `SHA-1` for a 160-bit (20-byte) hash or `SHA-256` for a 256-bit (32-byte) hash. To ensure a secure hash function, use `SHA-256`."""

    SHA_1 = "SHA-1"
    SHA_256 = "SHA-256"


class GetEnrollmentsTechContactTypedDict(TypedDict):
    r"""Contact information for an administrator at Akamai."""

    address_line_one: Nullable[str]
    r"""The address for an administrator at Akamai."""
    address_line_two: Nullable[str]
    r"""The address for an administrator at Akamai."""
    city: Nullable[str]
    r"""The city for an administrator at Akamai."""
    country: Nullable[str]
    r"""The country for an administrator at Akamai."""
    email: Nullable[str]
    r"""The email address of the administrator who you want to use as a contact at your company."""
    first_name: Nullable[str]
    r"""The first name of the technical contact who you want to use within Akamai. This is the person you work closest with at Akamai who can verify the certificate request. This is the person the CA calls if there are any issues with the certificate and they cannot reach the administrator."""
    last_name: Nullable[str]
    r"""The last name of the technical contact who you want to use within Akamai."""
    organization_name: Nullable[str]
    r"""The name of your organization in Akamai where your technical contact works."""
    phone: Nullable[str]
    r"""The phone number of the technical contact who you want to use within Akamai."""
    postal_code: Nullable[str]
    r"""The postal code for an administrator at Akamai."""
    region: Nullable[str]
    r"""The region for an administrator at Akamai."""
    title: Nullable[str]
    r"""The title for an administrator at Akamai."""


class GetEnrollmentsTechContact(BaseModel):
    r"""Contact information for an administrator at Akamai."""

    address_line_one: Annotated[Nullable[str], pydantic.Field(alias="addressLineOne")]
    r"""The address for an administrator at Akamai."""

    address_line_two: Annotated[Nullable[str], pydantic.Field(alias="addressLineTwo")]
    r"""The address for an administrator at Akamai."""

    city: Nullable[str]
    r"""The city for an administrator at Akamai."""

    country: Nullable[str]
    r"""The country for an administrator at Akamai."""

    email: Nullable[str]
    r"""The email address of the administrator who you want to use as a contact at your company."""

    first_name: Annotated[Nullable[str], pydantic.Field(alias="firstName")]
    r"""The first name of the technical contact who you want to use within Akamai. This is the person you work closest with at Akamai who can verify the certificate request. This is the person the CA calls if there are any issues with the certificate and they cannot reach the administrator."""

    last_name: Annotated[Nullable[str], pydantic.Field(alias="lastName")]
    r"""The last name of the technical contact who you want to use within Akamai."""

    organization_name: Annotated[
        Nullable[str], pydantic.Field(alias="organizationName")
    ]
    r"""The name of your organization in Akamai where your technical contact works."""

    phone: Nullable[str]
    r"""The phone number of the technical contact who you want to use within Akamai."""

    postal_code: Annotated[Nullable[str], pydantic.Field(alias="postalCode")]
    r"""The postal code for an administrator at Akamai."""

    region: Nullable[str]
    r"""The region for an administrator at Akamai."""

    title: Nullable[str]
    r"""The title for an administrator at Akamai."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = [
            "addressLineOne",
            "addressLineTwo",
            "city",
            "country",
            "email",
            "firstName",
            "lastName",
            "organizationName",
            "phone",
            "postalCode",
            "region",
            "title",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetEnrollmentsThirdPartyTypedDict(TypedDict):
    r"""Specifies that you want to use a third party certificate. This is any certificate that is not issued through CPS."""

    exclude_sans: bool
    r"""If this is `true`, then the SANs in the enrollment don't appear in the CSR that CPS submits to the CA."""


class GetEnrollmentsThirdParty(BaseModel):
    r"""Specifies that you want to use a third party certificate. This is any certificate that is not issued through CPS."""

    exclude_sans: Annotated[bool, pydantic.Field(alias="excludeSans")]
    r"""If this is `true`, then the SANs in the enrollment don't appear in the CSR that CPS submits to the CA."""


class GetEnrollmentsValidationType(str, Enum):
    r"""CPS supports several types of validation: `dv`, `ev`, `ov`, or `third-party`. Domain Validation (`dv`) offers the lowest level of validation. The CA validates that you have control of the domain. CPS supports DV certificates issued by Let's Encrypt, a free, automated, and open CA, run for public benefit. Organization Validation (`ov`) offers the next level of validation. The CA validates that you have control of the domain. Extended Validation (`ev`) offers the highest level of validation, in which you need to have signed letters and notaries sent to the CA before signing. You can also specify `third-party` if you want to use a signed certificate you obtain from a CA that CPS doesn't directly support."""

    DV = "dv"
    EV = "ev"
    OV = "ov"
    THIRD_PARTY = "third-party"


class GetEnrollmentsEnrollmentsTypedDict(TypedDict):
    r"""An enrollment displays all the information about the process that your certificate goes through from the time you request it, through renewal, and as you obtain subsequent versions. CPS is a certificate life cycle management tool. Once you obtain a certificate, you use it until it expires, in most cases a year from the date the CA issued the certificate. CPS automatically starts the renewal process 90 days before the old certificate expires. It then automatically deploys the renewed certificate when it receives it from the CA."""

    certificate_type: GetEnrollmentsCertificateType
    r"""Specifies the kind of certificate in the enrollment. Either san`, `single`, `wildcard`, `wildcard-san`, or `third-party. For details, see `validationType` in the [Enrollment object's versioned schema members](ref:enrollment#versioned-schema-members)."""
    change_management: bool
    r"""Setting this to `true` for an enrollment stops CPS from deploying the certificate to the network until you acknowledge you're ready to deploy the certificate. You can test the certificate outside of CPS, on the Edge Staging Network (ESN), to make sure it works in your environment, and then deploy the certificate. The ESN is a small network of Akamai edge servers built to simulate Akamai's production network to test most of your site or application functionality with current production version configuration options and functions. For more information on the ESN, see the [Edge Staging Network User Guide](https://control.akamai.com/dl/customers/other/EDGESERV/ESN-User-Guide.pdf). You can also contact your account representative with questions or issues with your service on the ESN."""
    csr: GetEnrollmentsCsrTypedDict
    r"""When you create an enrollment, you also generate a certificate signing request (CSR) using CPS. CPS signs the CSR with the private key. The CSR contains all the information the CA needs to issue your certificate."""
    enable_multi_stacked_certificates: bool
    r"""Enable Dual-Stacked certificate deployment for this enrollment. The next renewal includes the change. Note that this value is only returned for third-party certificates. Otherwise it's omitted from the response."""
    network_configuration: GetEnrollmentsNetworkConfigurationTypedDict
    r"""Settings that specify any network information and TLS Metadata you want CPS to use to push the completed certificate to the network."""
    ra: GetEnrollmentsRa
    r"""The registration authority or certificate authority (CA) you want to use to obtain a certificate. A CA is a trusted entity that signs certificates and can vouch for the identity of a website. This is either `symantec`,  `lets-encrypt`, or `third-party`."""
    validation_type: GetEnrollmentsValidationType
    r"""CPS supports several types of validation: `dv`, `ev`, `ov`, or `third-party`. Domain Validation (`dv`) offers the lowest level of validation. The CA validates that you have control of the domain. CPS supports DV certificates issued by Let's Encrypt, a free, automated, and open CA, run for public benefit. Organization Validation (`ov`) offers the next level of validation. The CA validates that you have control of the domain. Extended Validation (`ev`) offers the highest level of validation, in which you need to have signed letters and notaries sent to the CA before signing. You can also specify `third-party` if you want to use a signed certificate you obtain from a CA that CPS doesn't directly support."""
    admin_contact: NotRequired[Nullable[GetEnrollmentsAdminContactTypedDict]]
    r"""Contact information for the certificate administrator that you want to use as a contact at your company."""
    assigned_slots: NotRequired[Nullable[List[int]]]
    r"""Slots where the certificate is either deployed or is already deployed."""
    auto_renewal_start_time: NotRequired[Nullable[str]]
    r"""The specific date on which the renewal automatically starts for the enrollment."""
    certificate_chain_type: NotRequired[Nullable[GetEnrollmentsCertificateChainType]]
    r"""The kind of certificate trust chain. This is either `default` or `symantec1kroot`."""
    id: NotRequired[Nullable[str]]
    r"""The unique identifier of the enrollment."""
    location: NotRequired[Nullable[str]]
    r"""The URI path to the enrollment. The last segment of the URI path serves as a unique identifier for the enrollment."""
    max_allowed_san_names: NotRequired[Nullable[int]]
    r"""Maximum number of SAN names supported for this enrollment type."""
    max_allowed_wildcard_san_names: NotRequired[Nullable[int]]
    r"""Maximum number of Wildcard SAN names supported for this enrollment type."""
    org: NotRequired[Nullable[GetEnrollmentsOrgTypedDict]]
    r"""Your organization information."""
    org_id: NotRequired[Nullable[int]]
    r"""The Digicert unique identifier for the organization. If you use this value in a PUT or POST request, you can set the `org`, `techContact`, and `adminContact` values to `null`."""
    pending_changes: NotRequired[Nullable[List[GetEnrollmentsPendingChangesTypedDict]]]
    r"""Returns the Changes currently pending in CPS. The last item in the array is the most recent change."""
    production_slots: NotRequired[Nullable[List[int]]]
    r"""Slots where the certificate is deployed on the production network."""
    signature_algorithm: NotRequired[Nullable[GetEnrollmentsSignatureAlgorithm]]
    r"""Identifies the SHA (Secure Hash Algorithm) function. The NSA (National Security Agency) designed this function to produce a hash of certificate contents, for use in a digital signature. This is either `SHA-1` for a 160-bit (20-byte) hash or `SHA-256` for a 256-bit (32-byte) hash. To ensure a secure hash function, use `SHA-256`."""
    staging_slots: NotRequired[Nullable[List[int]]]
    r"""Slots where the certificate is deployed on the staging network."""
    tech_contact: NotRequired[Nullable[GetEnrollmentsTechContactTypedDict]]
    r"""Contact information for an administrator at Akamai."""
    third_party: NotRequired[Nullable[GetEnrollmentsThirdPartyTypedDict]]
    r"""Specifies that you want to use a third party certificate. This is any certificate that is not issued through CPS."""


class GetEnrollmentsEnrollments(BaseModel):
    r"""An enrollment displays all the information about the process that your certificate goes through from the time you request it, through renewal, and as you obtain subsequent versions. CPS is a certificate life cycle management tool. Once you obtain a certificate, you use it until it expires, in most cases a year from the date the CA issued the certificate. CPS automatically starts the renewal process 90 days before the old certificate expires. It then automatically deploys the renewed certificate when it receives it from the CA."""

    certificate_type: Annotated[
        GetEnrollmentsCertificateType, pydantic.Field(alias="certificateType")
    ]
    r"""Specifies the kind of certificate in the enrollment. Either san`, `single`, `wildcard`, `wildcard-san`, or `third-party. For details, see `validationType` in the [Enrollment object's versioned schema members](ref:enrollment#versioned-schema-members)."""

    change_management: Annotated[bool, pydantic.Field(alias="changeManagement")]
    r"""Setting this to `true` for an enrollment stops CPS from deploying the certificate to the network until you acknowledge you're ready to deploy the certificate. You can test the certificate outside of CPS, on the Edge Staging Network (ESN), to make sure it works in your environment, and then deploy the certificate. The ESN is a small network of Akamai edge servers built to simulate Akamai's production network to test most of your site or application functionality with current production version configuration options and functions. For more information on the ESN, see the [Edge Staging Network User Guide](https://control.akamai.com/dl/customers/other/EDGESERV/ESN-User-Guide.pdf). You can also contact your account representative with questions or issues with your service on the ESN."""

    csr: GetEnrollmentsCsr
    r"""When you create an enrollment, you also generate a certificate signing request (CSR) using CPS. CPS signs the CSR with the private key. The CSR contains all the information the CA needs to issue your certificate."""

    enable_multi_stacked_certificates: Annotated[
        bool, pydantic.Field(alias="enableMultiStackedCertificates")
    ]
    r"""Enable Dual-Stacked certificate deployment for this enrollment. The next renewal includes the change. Note that this value is only returned for third-party certificates. Otherwise it's omitted from the response."""

    network_configuration: Annotated[
        GetEnrollmentsNetworkConfiguration, pydantic.Field(alias="networkConfiguration")
    ]
    r"""Settings that specify any network information and TLS Metadata you want CPS to use to push the completed certificate to the network."""

    ra: GetEnrollmentsRa
    r"""The registration authority or certificate authority (CA) you want to use to obtain a certificate. A CA is a trusted entity that signs certificates and can vouch for the identity of a website. This is either `symantec`,  `lets-encrypt`, or `third-party`."""

    validation_type: Annotated[
        GetEnrollmentsValidationType, pydantic.Field(alias="validationType")
    ]
    r"""CPS supports several types of validation: `dv`, `ev`, `ov`, or `third-party`. Domain Validation (`dv`) offers the lowest level of validation. The CA validates that you have control of the domain. CPS supports DV certificates issued by Let's Encrypt, a free, automated, and open CA, run for public benefit. Organization Validation (`ov`) offers the next level of validation. The CA validates that you have control of the domain. Extended Validation (`ev`) offers the highest level of validation, in which you need to have signed letters and notaries sent to the CA before signing. You can also specify `third-party` if you want to use a signed certificate you obtain from a CA that CPS doesn't directly support."""

    admin_contact: Annotated[
        OptionalNullable[GetEnrollmentsAdminContact],
        pydantic.Field(alias="adminContact"),
    ] = UNSET
    r"""Contact information for the certificate administrator that you want to use as a contact at your company."""

    assigned_slots: Annotated[
        OptionalNullable[List[int]], pydantic.Field(alias="assignedSlots")
    ] = UNSET
    r"""Slots where the certificate is either deployed or is already deployed."""

    auto_renewal_start_time: Annotated[
        OptionalNullable[str], pydantic.Field(alias="autoRenewalStartTime")
    ] = UNSET
    r"""The specific date on which the renewal automatically starts for the enrollment."""

    certificate_chain_type: Annotated[
        OptionalNullable[GetEnrollmentsCertificateChainType],
        pydantic.Field(alias="certificateChainType"),
    ] = UNSET
    r"""The kind of certificate trust chain. This is either `default` or `symantec1kroot`."""

    id: OptionalNullable[str] = UNSET
    r"""The unique identifier of the enrollment."""

    location: OptionalNullable[str] = UNSET
    r"""The URI path to the enrollment. The last segment of the URI path serves as a unique identifier for the enrollment."""

    max_allowed_san_names: Annotated[
        OptionalNullable[int], pydantic.Field(alias="maxAllowedSanNames")
    ] = UNSET
    r"""Maximum number of SAN names supported for this enrollment type."""

    max_allowed_wildcard_san_names: Annotated[
        OptionalNullable[int], pydantic.Field(alias="maxAllowedWildcardSanNames")
    ] = UNSET
    r"""Maximum number of Wildcard SAN names supported for this enrollment type."""

    org: OptionalNullable[GetEnrollmentsOrg] = UNSET
    r"""Your organization information."""

    org_id: Annotated[OptionalNullable[int], pydantic.Field(alias="orgId")] = UNSET
    r"""The Digicert unique identifier for the organization. If you use this value in a PUT or POST request, you can set the `org`, `techContact`, and `adminContact` values to `null`."""

    pending_changes: Annotated[
        OptionalNullable[List[GetEnrollmentsPendingChanges]],
        pydantic.Field(alias="pendingChanges"),
    ] = UNSET
    r"""Returns the Changes currently pending in CPS. The last item in the array is the most recent change."""

    production_slots: Annotated[
        OptionalNullable[List[int]], pydantic.Field(alias="productionSlots")
    ] = UNSET
    r"""Slots where the certificate is deployed on the production network."""

    signature_algorithm: Annotated[
        OptionalNullable[GetEnrollmentsSignatureAlgorithm],
        pydantic.Field(alias="signatureAlgorithm"),
    ] = UNSET
    r"""Identifies the SHA (Secure Hash Algorithm) function. The NSA (National Security Agency) designed this function to produce a hash of certificate contents, for use in a digital signature. This is either `SHA-1` for a 160-bit (20-byte) hash or `SHA-256` for a 256-bit (32-byte) hash. To ensure a secure hash function, use `SHA-256`."""

    staging_slots: Annotated[
        OptionalNullable[List[int]], pydantic.Field(alias="stagingSlots")
    ] = UNSET
    r"""Slots where the certificate is deployed on the staging network."""

    tech_contact: Annotated[
        OptionalNullable[GetEnrollmentsTechContact], pydantic.Field(alias="techContact")
    ] = UNSET
    r"""Contact information for an administrator at Akamai."""

    third_party: Annotated[
        OptionalNullable[GetEnrollmentsThirdParty], pydantic.Field(alias="thirdParty")
    ] = UNSET
    r"""Specifies that you want to use a third party certificate. This is any certificate that is not issued through CPS."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "adminContact",
            "assignedSlots",
            "autoRenewalStartTime",
            "certificateChainType",
            "id",
            "location",
            "maxAllowedSanNames",
            "maxAllowedWildcardSanNames",
            "org",
            "orgId",
            "pendingChanges",
            "productionSlots",
            "signatureAlgorithm",
            "stagingSlots",
            "techContact",
            "thirdParty",
        ]
        nullable_fields = [
            "adminContact",
            "assignedSlots",
            "autoRenewalStartTime",
            "certificateChainType",
            "id",
            "location",
            "maxAllowedSanNames",
            "maxAllowedWildcardSanNames",
            "org",
            "orgId",
            "pendingChanges",
            "productionSlots",
            "signatureAlgorithm",
            "stagingSlots",
            "techContact",
            "thirdParty",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetEnrollmentsResponseBodyTypedDict(TypedDict):
    r"""Provides a list of enrollments."""

    enrollments: List[GetEnrollmentsEnrollmentsTypedDict]
    r"""The actual list of enrollments."""


class GetEnrollmentsResponseBody(BaseModel):
    r"""Provides a list of enrollments."""

    enrollments: List[GetEnrollmentsEnrollments]
    r"""The actual list of enrollments."""
