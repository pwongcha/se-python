"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from aktest_se.types import BaseModel, Nullable, UNSET_SENTINEL
from aktest_se.utils import FieldMetadata, PathParamMetadata, QueryParamMetadata
from enum import Enum
import pydantic
from pydantic import model_serializer
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class GetHistoryCertificatesRequestTypedDict(TypedDict):
    enrollment_id: int
    r"""Enrollment on which to perform the desired operation."""
    include_all: NotRequired[bool]
    r"""Retrieve all changes or certificates."""
    account_switch_key: NotRequired[str]
    r"""For customers who manage more than one account, this [runs the operation from another account](https://techdocs.akamai.com/developer/docs/manage-many-accounts-with-one-api-client). The Identity and Access Management API provides a [list of available account switch keys](https://techdocs.akamai.com/iam-api/reference/get-client-account-switch-keys)."""


class GetHistoryCertificatesRequest(BaseModel):
    enrollment_id: Annotated[
        int,
        pydantic.Field(alias="enrollmentId"),
        FieldMetadata(path=PathParamMetadata(style="simple", explode=False)),
    ]
    r"""Enrollment on which to perform the desired operation."""

    include_all: Annotated[
        Optional[bool],
        pydantic.Field(alias="includeAll"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = False
    r"""Retrieve all changes or certificates."""

    account_switch_key: Annotated[
        Optional[str],
        pydantic.Field(alias="accountSwitchKey"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""For customers who manage more than one account, this [runs the operation from another account](https://techdocs.akamai.com/developer/docs/manage-many-accounts-with-one-api-client). The Identity and Access Management API provides a [list of available account switch keys](https://techdocs.akamai.com/iam-api/reference/get-client-account-switch-keys)."""


class DeploymentStatus(str, Enum):
    r"""The current status of the certificate on the network. This is either `active` or `inactive`."""

    ACTIVE = "active"
    INACTIVE = "inactive"


class GetHistoryCertificatesGeography(str, Enum):
    r"""Specifies the type of network where you want to deploy your certificate.  Use `core` to deploy across most of the world except for specially licensed areas.  Use `china+core` to include China, or `russia+core` to include Russia. Any non-`core` deployment needs to be enabled on your contract based on approval from the Chinese or Russian governments."""

    CORE = "core"
    CHINA_PLUS_CORE = "china+core"
    RUSSIA_PLUS_CORE = "russia+core"


class GetHistoryCertificatesKeyAlgorithm(str, Enum):
    r"""The key algorithm for the multi-stacked certificate. This is either `ECDSA` or `RSA`."""

    ECDSA = "ECDSA"
    RSA = "RSA"


class GetHistoryCertificatesMultiStackedCertificatesTypedDict(TypedDict):
    certificate: Nullable[str]
    r"""The certificate text for the multi-stacked certificate."""
    expiry: str
    r"""The expiration date for the multi-stacked certificate."""
    key_algorithm: GetHistoryCertificatesKeyAlgorithm
    r"""The key algorithm for the multi-stacked certificate. This is either `ECDSA` or `RSA`."""
    trust_chain: Nullable[str]
    r"""The trust chain for the multi-stacked certificate."""


class GetHistoryCertificatesMultiStackedCertificates(BaseModel):
    certificate: Nullable[str]
    r"""The certificate text for the multi-stacked certificate."""

    expiry: str
    r"""The expiration date for the multi-stacked certificate."""

    key_algorithm: Annotated[
        GetHistoryCertificatesKeyAlgorithm, pydantic.Field(alias="keyAlgorithm")
    ]
    r"""The key algorithm for the multi-stacked certificate. This is either `ECDSA` or `RSA`."""

    trust_chain: Annotated[Nullable[str], pydantic.Field(alias="trustChain")]
    r"""The trust chain for the multi-stacked certificate."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["certificate", "trustChain"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetHistoryCertificatesEnrollmentsKeyAlgorithm(str, Enum):
    r"""The key algorithm for the primary certificate. This is either `ECDSA` or `RSA`."""

    ECDSA = "ECDSA"
    RSA = "RSA"


class GetHistoryCertificatesPrimaryCertificateTypedDict(TypedDict):
    r"""Primary certificate for Enrollment."""

    certificate: Nullable[str]
    r"""The primary certificate in the multi-stacked certificate."""
    expiry: str
    r"""The expiration date for the primary certificate."""
    key_algorithm: GetHistoryCertificatesEnrollmentsKeyAlgorithm
    r"""The key algorithm for the primary certificate. This is either `ECDSA` or `RSA`."""
    trust_chain: Nullable[str]
    r"""The trust chain for the primary certificate."""


class GetHistoryCertificatesPrimaryCertificate(BaseModel):
    r"""Primary certificate for Enrollment."""

    certificate: Nullable[str]
    r"""The primary certificate in the multi-stacked certificate."""

    expiry: str
    r"""The expiration date for the primary certificate."""

    key_algorithm: Annotated[
        GetHistoryCertificatesEnrollmentsKeyAlgorithm,
        pydantic.Field(alias="keyAlgorithm"),
    ]
    r"""The key algorithm for the primary certificate. This is either `ECDSA` or `RSA`."""

    trust_chain: Annotated[Nullable[str], pydantic.Field(alias="trustChain")]
    r"""The trust chain for the primary certificate."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["certificate", "trustChain"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class StagingStatus(str, Enum):
    r"""The staging status of the primary certificate, either `active` or `inactive`."""

    ACTIVE = "active"
    INACTIVE = "inactive"


class Type(str, Enum):
    r"""Determines the certificate's validation type and number of domains the certificate supports. This is either `san`, `single`, `wildcard`, `wildcard-san`, or `third-party`."""

    SAN = "san"
    SINGLE = "single"
    WILDCARD = "wildcard"
    WILDCARD_SAN = "wildcard-san"
    THIRD_PARTY = "third-party"


class GetHistoryCertificatesCertificatesTypedDict(TypedDict):
    deployment_status: DeploymentStatus
    r"""The current status of the certificate on the network. This is either `active` or `inactive`."""
    multi_stacked_certificates: List[
        GetHistoryCertificatesMultiStackedCertificatesTypedDict
    ]
    r"""Enables an ECDSA certificate in addition to an RSA certificate. CPS automatically performs all certificate operations on both certificates, and uses the best certificate for each client connection to your secure properties. Customers pinning certificates need to pin both the RSA and the ECDSA certificate. You should enable this feature. If its Third Party Dual Stack Certificate, fallback RSA certificate information is present in this."""
    primary_certificate: Nullable[GetHistoryCertificatesPrimaryCertificateTypedDict]
    r"""Primary certificate for Enrollment."""
    slots: List[int]
    r"""The slot numbers of the primary certificate."""
    staging_status: StagingStatus
    r"""The staging status of the primary certificate, either `active` or `inactive`."""
    type: Type
    r"""Determines the certificate's validation type and number of domains the certificate supports. This is either `san`, `single`, `wildcard`, `wildcard-san`, or `third-party`."""
    geography: NotRequired[GetHistoryCertificatesGeography]
    r"""Specifies the type of network where you want to deploy your certificate.  Use `core` to deploy across most of the world except for specially licensed areas.  Use `china+core` to include China, or `russia+core` to include Russia. Any non-`core` deployment needs to be enabled on your contract based on approval from the Chinese or Russian governments."""
    ra: NotRequired[str]
    r"""The certificate registration authority of the primary certificate."""


class GetHistoryCertificatesCertificates(BaseModel):
    deployment_status: Annotated[
        DeploymentStatus, pydantic.Field(alias="deploymentStatus")
    ]
    r"""The current status of the certificate on the network. This is either `active` or `inactive`."""

    multi_stacked_certificates: Annotated[
        List[GetHistoryCertificatesMultiStackedCertificates],
        pydantic.Field(alias="multiStackedCertificates"),
    ]
    r"""Enables an ECDSA certificate in addition to an RSA certificate. CPS automatically performs all certificate operations on both certificates, and uses the best certificate for each client connection to your secure properties. Customers pinning certificates need to pin both the RSA and the ECDSA certificate. You should enable this feature. If its Third Party Dual Stack Certificate, fallback RSA certificate information is present in this."""

    primary_certificate: Annotated[
        Nullable[GetHistoryCertificatesPrimaryCertificate],
        pydantic.Field(alias="primaryCertificate"),
    ]
    r"""Primary certificate for Enrollment."""

    slots: List[int]
    r"""The slot numbers of the primary certificate."""

    staging_status: Annotated[StagingStatus, pydantic.Field(alias="stagingStatus")]
    r"""The staging status of the primary certificate, either `active` or `inactive`."""

    type: Type
    r"""Determines the certificate's validation type and number of domains the certificate supports. This is either `san`, `single`, `wildcard`, `wildcard-san`, or `third-party`."""

    geography: Optional[GetHistoryCertificatesGeography] = None
    r"""Specifies the type of network where you want to deploy your certificate.  Use `core` to deploy across most of the world except for specially licensed areas.  Use `china+core` to include China, or `russia+core` to include Russia. Any non-`core` deployment needs to be enabled on your contract based on approval from the Chinese or Russian governments."""

    ra: Optional[str] = None
    r"""The certificate registration authority of the primary certificate."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["geography", "ra"]
        nullable_fields = ["primaryCertificate"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetHistoryCertificatesResponseBodyTypedDict(TypedDict):
    r"""You can view the current and previous certificates as part of the certificate history. You retrieve each iteration in the history of your certificate by certificate type, and also view the status, expiration date, and certificate authority for the certificate. You can take actions on each activity of the certificate, including, view the certificate and view the trust chain for the certificate."""

    certificates: List[GetHistoryCertificatesCertificatesTypedDict]
    r"""The type of certificate. This could be a single certificate, which associates a property hostname with a single name. It could be a wildcard certificate, which secures an entire property hostname. It could be a SAN certificate, in which case you can use Subject Alternative Names to secure up to 100 property hostnames with one certificate. It could also be a wildcard SAN certificate, which is a SAN certificate that can have up to 100 SANs with 25 wildcard entries in the SAN list. Or you can have a third-party certificate, a signed certificate you obtain from an external certificate authority."""


class GetHistoryCertificatesResponseBody(BaseModel):
    r"""You can view the current and previous certificates as part of the certificate history. You retrieve each iteration in the history of your certificate by certificate type, and also view the status, expiration date, and certificate authority for the certificate. You can take actions on each activity of the certificate, including, view the certificate and view the trust chain for the certificate."""

    certificates: List[GetHistoryCertificatesCertificates]
    r"""The type of certificate. This could be a single certificate, which associates a property hostname with a single name. It could be a wildcard certificate, which secures an entire property hostname. It could be a SAN certificate, in which case you can use Subject Alternative Names to secure up to 100 property hostnames with one certificate. It could also be a wildcard SAN certificate, which is a SAN certificate that can have up to 100 SANs with 25 wildcard entries in the SAN list. Or you can have a third-party certificate, a signed certificate you obtain from an external certificate authority."""
