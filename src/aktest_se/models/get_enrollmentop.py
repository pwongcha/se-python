"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from aktest_se.types import BaseModel, Nullable, OptionalNullable, UNSET, UNSET_SENTINEL
from aktest_se.utils import FieldMetadata, PathParamMetadata, QueryParamMetadata
from enum import Enum
import pydantic
from pydantic import model_serializer
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class GetEnrollmentRequestTypedDict(TypedDict):
    enrollment_id: int
    r"""Enrollment on which to perform the desired operation."""
    account_switch_key: NotRequired[str]
    r"""For customers who manage more than one account, this [runs the operation from another account](https://techdocs.akamai.com/developer/docs/manage-many-accounts-with-one-api-client). The Identity and Access Management API provides a [list of available account switch keys](https://techdocs.akamai.com/iam-api/reference/get-client-account-switch-keys)."""


class GetEnrollmentRequest(BaseModel):
    enrollment_id: Annotated[
        int,
        pydantic.Field(alias="enrollmentId"),
        FieldMetadata(path=PathParamMetadata(style="simple", explode=False)),
    ]
    r"""Enrollment on which to perform the desired operation."""

    account_switch_key: Annotated[
        Optional[str],
        pydantic.Field(alias="accountSwitchKey"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""For customers who manage more than one account, this [runs the operation from another account](https://techdocs.akamai.com/developer/docs/manage-many-accounts-with-one-api-client). The Identity and Access Management API provides a [list of available account switch keys](https://techdocs.akamai.com/iam-api/reference/get-client-account-switch-keys)."""


class GetEnrollmentAdminContactTypedDict(TypedDict):
    r"""Contact information for the certificate administrator that you want to use as a contact at your company."""

    address_line_one: Nullable[str]
    r"""The address of your organization."""
    address_line_two: Nullable[str]
    r"""The address of your organization."""
    city: Nullable[str]
    r"""The city where your organization resides."""
    country: Nullable[str]
    r"""The country where your organization resides."""
    email: Nullable[str]
    r"""The email address of the administrator who you want to use as a contact at your company."""
    first_name: Nullable[str]
    r"""The first name of the administrator who you want to use as a contact at your company."""
    last_name: Nullable[str]
    r"""The last name of the administrator who you want to use as a contact at your company."""
    organization_name: Nullable[str]
    r"""The name of your organization."""
    phone: Nullable[str]
    r"""The phone number of your organization."""
    postal_code: Nullable[str]
    r"""The postal code of your organization."""
    region: Nullable[str]
    r"""The region of your organization, typically a state or province."""
    title: Nullable[str]
    r"""The title of the administrator who you want to use as a contact at your company."""


class GetEnrollmentAdminContact(BaseModel):
    r"""Contact information for the certificate administrator that you want to use as a contact at your company."""

    address_line_one: Annotated[Nullable[str], pydantic.Field(alias="addressLineOne")]
    r"""The address of your organization."""

    address_line_two: Annotated[Nullable[str], pydantic.Field(alias="addressLineTwo")]
    r"""The address of your organization."""

    city: Nullable[str]
    r"""The city where your organization resides."""

    country: Nullable[str]
    r"""The country where your organization resides."""

    email: Nullable[str]
    r"""The email address of the administrator who you want to use as a contact at your company."""

    first_name: Annotated[Nullable[str], pydantic.Field(alias="firstName")]
    r"""The first name of the administrator who you want to use as a contact at your company."""

    last_name: Annotated[Nullable[str], pydantic.Field(alias="lastName")]
    r"""The last name of the administrator who you want to use as a contact at your company."""

    organization_name: Annotated[
        Nullable[str], pydantic.Field(alias="organizationName")
    ]
    r"""The name of your organization."""

    phone: Nullable[str]
    r"""The phone number of your organization."""

    postal_code: Annotated[Nullable[str], pydantic.Field(alias="postalCode")]
    r"""The postal code of your organization."""

    region: Nullable[str]
    r"""The region of your organization, typically a state or province."""

    title: Nullable[str]
    r"""The title of the administrator who you want to use as a contact at your company."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = [
            "addressLineOne",
            "addressLineTwo",
            "city",
            "country",
            "email",
            "firstName",
            "lastName",
            "organizationName",
            "phone",
            "postalCode",
            "region",
            "title",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetEnrollmentCertificateChainType(str, Enum):
    r"""The kind of certificate trust chain. This is either `default` or `symantec1kroot`."""

    DEFAULT = "default"
    SYMANTEC1KROOT = "symantec1kroot"


class GetEnrollmentCertificateType(str, Enum):
    r"""Either `san`, `single`, `wildcard`, `wildcard-san`, or `third-party`. See [Enrollment.validationType Values](#validationtype) for details."""

    SAN = "san"
    SINGLE = "single"
    WILDCARD = "wildcard"
    WILDCARD_SAN = "wildcard-san"
    THIRD_PARTY = "third-party"


class GetEnrollmentCsrTypedDict(TypedDict):
    r"""When you create an enrollment, you also generate a certificate signing request (CSR) using CPS. CPS signs the CSR with the private key. The CSR contains all the information the CA needs to issue your certificate."""

    cn: str
    r"""The domain name to use for the certificate, also known as the _common name_. Note that the organization specified as the `o` needs to own or have legal rights to this domain name."""
    c: NotRequired[Nullable[str]]
    r"""The country code for the country where your organization is located."""
    l: NotRequired[Nullable[str]]
    r"""Your city in the locality (city)."""
    o: NotRequired[Nullable[str]]
    r"""The name of your company or organization. Enter the name as it appears in all legal documents and as it appears in the legal entity filing."""
    ou: NotRequired[Nullable[str]]
    r"""Your organizational unit."""
    preferred_trust_chain: NotRequired[Nullable[str]]
    r"""For the Let's Encrypt Domain Validated (DV) SAN certificates, a preferred trust chain isn't needed. The default value is `null`."""
    sans: NotRequired[Nullable[List[str]]]
    r"""Additional `cn` values to create a Subject Alternative Names (SAN) list. If there are no SANs, the response shows an empty list. Removing a SAN list from an enrollment may disrupt your service for TLS connections."""
    st: NotRequired[Nullable[str]]
    r"""Your state or province."""


class GetEnrollmentCsr(BaseModel):
    r"""When you create an enrollment, you also generate a certificate signing request (CSR) using CPS. CPS signs the CSR with the private key. The CSR contains all the information the CA needs to issue your certificate."""

    cn: str
    r"""The domain name to use for the certificate, also known as the _common name_. Note that the organization specified as the `o` needs to own or have legal rights to this domain name."""

    c: OptionalNullable[str] = UNSET
    r"""The country code for the country where your organization is located."""

    l: OptionalNullable[str] = UNSET
    r"""Your city in the locality (city)."""

    o: OptionalNullable[str] = UNSET
    r"""The name of your company or organization. Enter the name as it appears in all legal documents and as it appears in the legal entity filing."""

    ou: OptionalNullable[str] = UNSET
    r"""Your organizational unit."""

    preferred_trust_chain: Annotated[
        OptionalNullable[str], pydantic.Field(alias="preferredTrustChain")
    ] = UNSET
    r"""For the Let's Encrypt Domain Validated (DV) SAN certificates, a preferred trust chain isn't needed. The default value is `null`."""

    sans: OptionalNullable[List[str]] = UNSET
    r"""Additional `cn` values to create a Subject Alternative Names (SAN) list. If there are no SANs, the response shows an empty list. Removing a SAN list from an enrollment may disrupt your service for TLS connections."""

    st: OptionalNullable[str] = UNSET
    r"""Your state or province."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["c", "l", "o", "ou", "preferredTrustChain", "sans", "st"]
        nullable_fields = ["c", "l", "o", "ou", "preferredTrustChain", "sans", "st"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetEnrollmentOcspTypedDict(TypedDict):
    r"""Whether you want to enable OCSP stapling for client certificates."""

    enabled: Nullable[bool]
    r"""Whether the OCSP stapling is enabled."""


class GetEnrollmentOcsp(BaseModel):
    r"""Whether you want to enable OCSP stapling for client certificates."""

    enabled: Nullable[bool]
    r"""Whether the OCSP stapling is enabled."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["enabled"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetEnrollmentAuthenticationOptionsTypedDict(TypedDict):
    r"""Contains the configuration options for the selected trust chain."""

    ocsp: Nullable[GetEnrollmentOcspTypedDict]
    r"""Whether you want to enable OCSP stapling for client certificates."""
    send_ca_list_to_client: Nullable[bool]
    r"""Whether you want to enable the server to send the certificate authority (CA) list to the client."""


class GetEnrollmentAuthenticationOptions(BaseModel):
    r"""Contains the configuration options for the selected trust chain."""

    ocsp: Nullable[GetEnrollmentOcsp]
    r"""Whether you want to enable OCSP stapling for client certificates."""

    send_ca_list_to_client: Annotated[
        Nullable[bool], pydantic.Field(alias="sendCaListToClient")
    ]
    r"""Whether you want to enable the server to send the certificate authority (CA) list to the client."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["ocsp", "sendCaListToClient"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetEnrollmentClientMutualAuthenticationTypedDict(TypedDict):
    r"""The configuration for client mutual authentication. Specifies the trust chain that verifies client certificates and some configuration options."""

    authentication_options: Nullable[GetEnrollmentAuthenticationOptionsTypedDict]
    r"""Contains the configuration options for the selected trust chain."""
    set_id: NotRequired[Nullable[str]]
    r"""The identifier of the set of trust chains, created in the [Mutual TLS Edge Truststore](https://techdocs.akamai.com/mtls-edge-truststore/docs)."""


class GetEnrollmentClientMutualAuthentication(BaseModel):
    r"""The configuration for client mutual authentication. Specifies the trust chain that verifies client certificates and some configuration options."""

    authentication_options: Annotated[
        Nullable[GetEnrollmentAuthenticationOptions],
        pydantic.Field(alias="authenticationOptions"),
    ]
    r"""Contains the configuration options for the selected trust chain."""

    set_id: Annotated[OptionalNullable[str], pydantic.Field(alias="setId")] = UNSET
    r"""The identifier of the set of trust chains, created in the [Mutual TLS Edge Truststore](https://techdocs.akamai.com/mtls-edge-truststore/docs)."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["setId"]
        nullable_fields = ["authenticationOptions", "setId"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetEnrollmentDNSNameSettingsTypedDict(TypedDict):
    r"""DNS name settings."""

    clone_dns_names: bool
    r"""Enable if you want CPS to direct traffic using all the SANs listed in the SANs parameter when you created your enrollment."""
    dns_names: NotRequired[Nullable[List[str]]]
    r"""Names served by SNI-only enabled enrollments."""


class GetEnrollmentDNSNameSettings(BaseModel):
    r"""DNS name settings."""

    clone_dns_names: Annotated[bool, pydantic.Field(alias="cloneDnsNames")]
    r"""Enable if you want CPS to direct traffic using all the SANs listed in the SANs parameter when you created your enrollment."""

    dns_names: Annotated[
        OptionalNullable[List[str]], pydantic.Field(alias="dnsNames")
    ] = UNSET
    r"""Names served by SNI-only enabled enrollments."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["dnsNames"]
        nullable_fields = ["dnsNames"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetEnrollmentGeography(str, Enum):
    r"""Specifies the type of network where you want to deploy your certificate.  Use `core` to deploy across most of the world except for specially licensed areas.  Use `china+core` to include China, or `russia+core` to include Russia. Any non-`core` deployment needs to be enabled on your contract based on approval from the Chinese or Russian governments."""

    CORE = "core"
    CHINA_PLUS_CORE = "china+core"
    RUSSIA_PLUS_CORE = "russia+core"


class GetEnrollmentOcspStapling(str, Enum):
    r"""Enable OCSP stapling for the enrollment. OCSP Stapling improves performance by including a valid OCSP response in every TLS handshake. Specify OCSP Stapling if you want to improve performance by allowing your site's visitors to query the Online Certificate Status Protocol (OCSP) server at regular intervals to obtain a signed time-stamped OCSP response. This response needs to be signed by the CA, not the server, therefore ensuring security. Disable OSCP Stapling if you want your site's visitors to contact the CA directly for an OSCP response. You can use OCSP to obtain a certificate's revocation status. You should enable this feature. Use `on` to enable OSCP Stapling, `off` to disable it, or `not-set` to ignore it."""

    ON = "on"
    OFF = "off"
    NOT_SET = "not-set"


class GetEnrollmentSecureNetwork(str, Enum):
    r"""Identifies the type of deployment network. `enhanced-tls` means Akamai's more secure network with PCI compliance capability, while `standard-tls` means Akamai's standard secure network."""

    ENHANCED_TLS = "enhanced-tls"
    STANDARD_TLS = "standard-tls"


class GetEnrollmentNetworkConfigurationTypedDict(TypedDict):
    r"""Settings that specify any network information and TLS Metadata you want CPS to use to push the completed certificate to the network."""

    geography: GetEnrollmentGeography
    r"""Specifies the type of network where you want to deploy your certificate.  Use `core` to deploy across most of the world except for specially licensed areas.  Use `china+core` to include China, or `russia+core` to include Russia. Any non-`core` deployment needs to be enabled on your contract based on approval from the Chinese or Russian governments."""
    quic_enabled: bool
    r"""Set to `true` to enable QUIC protocol."""
    secure_network: GetEnrollmentSecureNetwork
    r"""Identifies the type of deployment network. `enhanced-tls` means Akamai's more secure network with PCI compliance capability, while `standard-tls` means Akamai's standard secure network."""
    sni_only: bool
    r"""SNI settings for your enrollment. Set to `true` to enable SNI-only for the enrollment. This setting cannot be changed once an enrollment is created."""
    client_mutual_authentication: NotRequired[
        Nullable[GetEnrollmentClientMutualAuthenticationTypedDict]
    ]
    r"""The configuration for client mutual authentication. Specifies the trust chain that verifies client certificates and some configuration options."""
    disallowed_tls_versions: NotRequired[Nullable[List[str]]]
    r"""Specify the TLS protocol versions you want to disallow."""
    dns_name_settings: NotRequired[Nullable[GetEnrollmentDNSNameSettingsTypedDict]]
    r"""DNS name settings."""
    fips_mode: NotRequired[Nullable[bool]]
    r"""Enables Federal Information Processing Standards (FIPS) for the enrollment. When enabled, you need to use an active (non-deprecated) cipher profile for both `mustHaveCiphers` and `preferredCiphers`. For details, see [Update SSL/TLS cipher profiles](doc:cipher-profiles)."""
    must_have_ciphers: NotRequired[Nullable[str]]
    r"""Ciphers that you definitely want to include for your enrollment while deploying it on the network. Defaults to `ak-akamai-default` when it is not set."""
    ocsp_stapling: NotRequired[Nullable[GetEnrollmentOcspStapling]]
    r"""Enable OCSP stapling for the enrollment. OCSP Stapling improves performance by including a valid OCSP response in every TLS handshake. Specify OCSP Stapling if you want to improve performance by allowing your site's visitors to query the Online Certificate Status Protocol (OCSP) server at regular intervals to obtain a signed time-stamped OCSP response. This response needs to be signed by the CA, not the server, therefore ensuring security. Disable OSCP Stapling if you want your site's visitors to contact the CA directly for an OSCP response. You can use OCSP to obtain a certificate's revocation status. You should enable this feature. Use `on` to enable OSCP Stapling, `off` to disable it, or `not-set` to ignore it."""
    preferred_ciphers: NotRequired[Nullable[str]]
    r"""Ciphers that you preferably want to include for your enrollment while deploying it on the network. Defaults to `ak-akamai-default` when it is not set."""


class GetEnrollmentNetworkConfiguration(BaseModel):
    r"""Settings that specify any network information and TLS Metadata you want CPS to use to push the completed certificate to the network."""

    geography: GetEnrollmentGeography
    r"""Specifies the type of network where you want to deploy your certificate.  Use `core` to deploy across most of the world except for specially licensed areas.  Use `china+core` to include China, or `russia+core` to include Russia. Any non-`core` deployment needs to be enabled on your contract based on approval from the Chinese or Russian governments."""

    quic_enabled: Annotated[bool, pydantic.Field(alias="quicEnabled")]
    r"""Set to `true` to enable QUIC protocol."""

    secure_network: Annotated[
        GetEnrollmentSecureNetwork, pydantic.Field(alias="secureNetwork")
    ]
    r"""Identifies the type of deployment network. `enhanced-tls` means Akamai's more secure network with PCI compliance capability, while `standard-tls` means Akamai's standard secure network."""

    sni_only: Annotated[bool, pydantic.Field(alias="sniOnly")]
    r"""SNI settings for your enrollment. Set to `true` to enable SNI-only for the enrollment. This setting cannot be changed once an enrollment is created."""

    client_mutual_authentication: Annotated[
        OptionalNullable[GetEnrollmentClientMutualAuthentication],
        pydantic.Field(alias="clientMutualAuthentication"),
    ] = UNSET
    r"""The configuration for client mutual authentication. Specifies the trust chain that verifies client certificates and some configuration options."""

    disallowed_tls_versions: Annotated[
        OptionalNullable[List[str]], pydantic.Field(alias="disallowedTlsVersions")
    ] = UNSET
    r"""Specify the TLS protocol versions you want to disallow."""

    dns_name_settings: Annotated[
        OptionalNullable[GetEnrollmentDNSNameSettings],
        pydantic.Field(alias="dnsNameSettings"),
    ] = UNSET
    r"""DNS name settings."""

    fips_mode: Annotated[OptionalNullable[bool], pydantic.Field(alias="fipsMode")] = (
        UNSET
    )
    r"""Enables Federal Information Processing Standards (FIPS) for the enrollment. When enabled, you need to use an active (non-deprecated) cipher profile for both `mustHaveCiphers` and `preferredCiphers`. For details, see [Update SSL/TLS cipher profiles](doc:cipher-profiles)."""

    must_have_ciphers: Annotated[
        OptionalNullable[str], pydantic.Field(alias="mustHaveCiphers")
    ] = UNSET
    r"""Ciphers that you definitely want to include for your enrollment while deploying it on the network. Defaults to `ak-akamai-default` when it is not set."""

    ocsp_stapling: Annotated[
        OptionalNullable[GetEnrollmentOcspStapling],
        pydantic.Field(alias="ocspStapling"),
    ] = UNSET
    r"""Enable OCSP stapling for the enrollment. OCSP Stapling improves performance by including a valid OCSP response in every TLS handshake. Specify OCSP Stapling if you want to improve performance by allowing your site's visitors to query the Online Certificate Status Protocol (OCSP) server at regular intervals to obtain a signed time-stamped OCSP response. This response needs to be signed by the CA, not the server, therefore ensuring security. Disable OSCP Stapling if you want your site's visitors to contact the CA directly for an OSCP response. You can use OCSP to obtain a certificate's revocation status. You should enable this feature. Use `on` to enable OSCP Stapling, `off` to disable it, or `not-set` to ignore it."""

    preferred_ciphers: Annotated[
        OptionalNullable[str], pydantic.Field(alias="preferredCiphers")
    ] = UNSET
    r"""Ciphers that you preferably want to include for your enrollment while deploying it on the network. Defaults to `ak-akamai-default` when it is not set."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "clientMutualAuthentication",
            "disallowedTlsVersions",
            "dnsNameSettings",
            "fipsMode",
            "mustHaveCiphers",
            "ocspStapling",
            "preferredCiphers",
        ]
        nullable_fields = [
            "clientMutualAuthentication",
            "disallowedTlsVersions",
            "dnsNameSettings",
            "fipsMode",
            "mustHaveCiphers",
            "ocspStapling",
            "preferredCiphers",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetEnrollmentOrgTypedDict(TypedDict):
    r"""Your organization information."""

    address_line_one: Nullable[str]
    r"""The address of your organization."""
    address_line_two: Nullable[str]
    r"""The address of your organization."""
    city: Nullable[str]
    r"""The city where your organization resides."""
    country: Nullable[str]
    r"""The country where your organization resides."""
    name: Nullable[str]
    r"""The name of your organization."""
    phone: Nullable[str]
    r"""The phone number of the administrator who you want to use as a contact at your company."""
    postal_code: Nullable[str]
    r"""The postal code of your organization."""
    region: Nullable[str]
    r"""The region where your organization resides."""


class GetEnrollmentOrg(BaseModel):
    r"""Your organization information."""

    address_line_one: Annotated[Nullable[str], pydantic.Field(alias="addressLineOne")]
    r"""The address of your organization."""

    address_line_two: Annotated[Nullable[str], pydantic.Field(alias="addressLineTwo")]
    r"""The address of your organization."""

    city: Nullable[str]
    r"""The city where your organization resides."""

    country: Nullable[str]
    r"""The country where your organization resides."""

    name: Nullable[str]
    r"""The name of your organization."""

    phone: Nullable[str]
    r"""The phone number of the administrator who you want to use as a contact at your company."""

    postal_code: Annotated[Nullable[str], pydantic.Field(alias="postalCode")]
    r"""The postal code of your organization."""

    region: Nullable[str]
    r"""The region where your organization resides."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = [
            "addressLineOne",
            "addressLineTwo",
            "city",
            "country",
            "name",
            "phone",
            "postalCode",
            "region",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetEnrollmentChangeType(str, Enum):
    r"""Indicates the certificate's pending change action. This is either `new-certificate`, `modify-certificate`, `modify-san`, or `renewal`."""

    NEW_CERTIFICATE = "new-certificate"
    MODIFY_CERTIFICATE = "modify-certificate"
    MODIFY_SAN = "modify-san"
    RENEWAL = "renewal"


class GetEnrollmentPendingChangesTypedDict(TypedDict):
    location: str
    r"""Location to fetch related change information."""
    change_type: NotRequired[Nullable[GetEnrollmentChangeType]]
    r"""Indicates the certificate's pending change action. This is either `new-certificate`, `modify-certificate`, `modify-san`, or `renewal`."""


class GetEnrollmentPendingChanges(BaseModel):
    location: str
    r"""Location to fetch related change information."""

    change_type: Annotated[
        OptionalNullable[GetEnrollmentChangeType], pydantic.Field(alias="changeType")
    ] = UNSET
    r"""Indicates the certificate's pending change action. This is either `new-certificate`, `modify-certificate`, `modify-san`, or `renewal`."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["changeType"]
        nullable_fields = ["changeType"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetEnrollmentRa(str, Enum):
    r"""The registration authority or certificate authority (CA) you want to use to obtain a certificate. A CA is a trusted entity that signs certificates and can vouch for the identity of a website. This is either `symantec`,  `lets-encrypt`, or `third-party`."""

    SYMANTEC = "symantec"
    LETS_ENCRYPT = "lets-encrypt"
    THIRD_PARTY = "third-party"


class GetEnrollmentSignatureAlgorithm(str, Enum):
    r"""Identifies the SHA (Secure Hash Algorithm) function. The NSA (National Security Agency) designed this function to produce a hash of certificate contents, for use in a digital signature. This is either `SHA-1` for a 160-bit (20-byte) hash or `SHA-256` for a 256-bit (32-byte) hash. To ensure a secure hash function, use `SHA-256`."""

    SHA_1 = "SHA-1"
    SHA_256 = "SHA-256"


class GetEnrollmentTechContactTypedDict(TypedDict):
    r"""Contact information for an administrator at Akamai."""

    address_line_one: Nullable[str]
    r"""The address for an administrator at Akamai."""
    address_line_two: Nullable[str]
    r"""The address for an administrator at Akamai."""
    city: Nullable[str]
    r"""The city for an administrator at Akamai."""
    country: Nullable[str]
    r"""The country for an administrator at Akamai."""
    email: Nullable[str]
    r"""The email address of the administrator who you want to use as a contact at your company."""
    first_name: Nullable[str]
    r"""The first name of the technical contact who you want to use within Akamai. This is the person you work closest with at Akamai who can verify the certificate request. This is the person the CA calls if there are any issues with the certificate and they cannot reach the administrator."""
    last_name: Nullable[str]
    r"""The last name of the technical contact who you want to use within Akamai."""
    organization_name: Nullable[str]
    r"""The name of your organization in Akamai where your technical contact works."""
    phone: Nullable[str]
    r"""The phone number of the technical contact who you want to use within Akamai."""
    postal_code: Nullable[str]
    r"""The postal code for an administrator at Akamai."""
    region: Nullable[str]
    r"""The region for an administrator at Akamai."""
    title: Nullable[str]
    r"""The title for an administrator at Akamai."""


class GetEnrollmentTechContact(BaseModel):
    r"""Contact information for an administrator at Akamai."""

    address_line_one: Annotated[Nullable[str], pydantic.Field(alias="addressLineOne")]
    r"""The address for an administrator at Akamai."""

    address_line_two: Annotated[Nullable[str], pydantic.Field(alias="addressLineTwo")]
    r"""The address for an administrator at Akamai."""

    city: Nullable[str]
    r"""The city for an administrator at Akamai."""

    country: Nullable[str]
    r"""The country for an administrator at Akamai."""

    email: Nullable[str]
    r"""The email address of the administrator who you want to use as a contact at your company."""

    first_name: Annotated[Nullable[str], pydantic.Field(alias="firstName")]
    r"""The first name of the technical contact who you want to use within Akamai. This is the person you work closest with at Akamai who can verify the certificate request. This is the person the CA calls if there are any issues with the certificate and they cannot reach the administrator."""

    last_name: Annotated[Nullable[str], pydantic.Field(alias="lastName")]
    r"""The last name of the technical contact who you want to use within Akamai."""

    organization_name: Annotated[
        Nullable[str], pydantic.Field(alias="organizationName")
    ]
    r"""The name of your organization in Akamai where your technical contact works."""

    phone: Nullable[str]
    r"""The phone number of the technical contact who you want to use within Akamai."""

    postal_code: Annotated[Nullable[str], pydantic.Field(alias="postalCode")]
    r"""The postal code for an administrator at Akamai."""

    region: Nullable[str]
    r"""The region for an administrator at Akamai."""

    title: Nullable[str]
    r"""The title for an administrator at Akamai."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = [
            "addressLineOne",
            "addressLineTwo",
            "city",
            "country",
            "email",
            "firstName",
            "lastName",
            "organizationName",
            "phone",
            "postalCode",
            "region",
            "title",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetEnrollmentThirdPartyTypedDict(TypedDict):
    r"""Specifies that you want to use a third party certificate. This is any certificate that is not issued through CPS."""

    exclude_sans: bool
    r"""If this is `true`, then the SANs in the enrollment don't appear in the CSR that CPS submits to the CA."""


class GetEnrollmentThirdParty(BaseModel):
    r"""Specifies that you want to use a third party certificate. This is any certificate that is not issued through CPS."""

    exclude_sans: Annotated[bool, pydantic.Field(alias="excludeSans")]
    r"""If this is `true`, then the SANs in the enrollment don't appear in the CSR that CPS submits to the CA."""


class GetEnrollmentValidationType(str, Enum):
    r"""CPS supports several types of validation: `dv`, `ev`, `ov`, or `third-party`. Domain Validation (`dv`) offers the lowest level of validation. The CA validates that you have control of the domain. CPS supports DV certificates issued by Let's Encrypt, a free, automated, and open CA, run for public benefit. Organization Validation (`ov`) offers the next level of validation. The CA validates that you have control of the domain. Extended Validation (`ev`) offers the highest level of validation, in which you need to have signed letters and notaries sent to the CA before signing. You can also specify `third-party` if you want to use a signed certificate you obtain from a CA that CPS doesn't directly support."""

    DV = "dv"
    EV = "ev"
    OV = "ov"
    THIRD_PARTY = "third-party"


class GetEnrollmentResponseBodyTypedDict(TypedDict):
    r"""An enrollment displays all the information about the process that your certificate goes through from the time you request it, through renewal, and as you obtain subsequent versions. CPS is a certificate life cycle management tool. Once you obtain a certificate, you use it until it expires, in most cases a year from the date the CA issued the certificate. CPS automatically starts the renewal process 90 days before the old certificate expires. It then automatically deploys the renewed certificate when it receives it from the CA."""

    certificate_type: GetEnrollmentCertificateType
    r"""Either `san`, `single`, `wildcard`, `wildcard-san`, or `third-party`. See [Enrollment.validationType Values](#validationtype) for details."""
    change_management: bool
    r"""Setting this to `true` for an enrollment stops CPS from deploying the certificate to the network until you acknowledge you're ready to deploy the certificate. You can test the certificate outside of CPS, on the Edge Staging Network (ESN), to make sure it works in your environment, and then deploy the certificate. The ESN is a small network of Akamai edge servers built to simulate Akamai's production network to test most of your site or application functionality with current production version configuration options and functions. For more information on the ESN, see the [Edge Staging Network User Guide](https://control.akamai.com/dl/customers/other/EDGESERV/ESN-User-Guide.pdf). You can also contact your account representative with questions or issues with your service on the ESN."""
    csr: GetEnrollmentCsrTypedDict
    r"""When you create an enrollment, you also generate a certificate signing request (CSR) using CPS. CPS signs the CSR with the private key. The CSR contains all the information the CA needs to issue your certificate."""
    enable_multi_stacked_certificates: bool
    r"""Enable Dual-Stacked certificate deployment for this enrollment. The next renewal includes the change. Note that this value is only returned for third-party certificates. Otherwise it's omitted from the response."""
    network_configuration: GetEnrollmentNetworkConfigurationTypedDict
    r"""Settings that specify any network information and TLS Metadata you want CPS to use to push the completed certificate to the network."""
    ra: GetEnrollmentRa
    r"""The registration authority or certificate authority (CA) you want to use to obtain a certificate. A CA is a trusted entity that signs certificates and can vouch for the identity of a website. This is either `symantec`,  `lets-encrypt`, or `third-party`."""
    validation_type: GetEnrollmentValidationType
    r"""CPS supports several types of validation: `dv`, `ev`, `ov`, or `third-party`. Domain Validation (`dv`) offers the lowest level of validation. The CA validates that you have control of the domain. CPS supports DV certificates issued by Let's Encrypt, a free, automated, and open CA, run for public benefit. Organization Validation (`ov`) offers the next level of validation. The CA validates that you have control of the domain. Extended Validation (`ev`) offers the highest level of validation, in which you need to have signed letters and notaries sent to the CA before signing. You can also specify `third-party` if you want to use a signed certificate you obtain from a CA that CPS doesn't directly support."""
    admin_contact: NotRequired[Nullable[GetEnrollmentAdminContactTypedDict]]
    r"""Contact information for the certificate administrator that you want to use as a contact at your company."""
    assigned_slots: NotRequired[Nullable[List[int]]]
    r"""Slots where the certificate is either deployed or is already deployed."""
    auto_renewal_start_time: NotRequired[Nullable[str]]
    r"""The specific date on which the renewal automatically starts for the enrollment."""
    certificate_chain_type: NotRequired[Nullable[GetEnrollmentCertificateChainType]]
    r"""The kind of certificate trust chain. This is either `default` or `symantec1kroot`."""
    id: NotRequired[Nullable[str]]
    r"""The unique identifier of the enrollment."""
    location: NotRequired[Nullable[str]]
    r"""The URI path to the enrollment. The last segment of the URI path serves as a unique identifier for the enrollment."""
    max_allowed_san_names: NotRequired[Nullable[int]]
    r"""Maximum number of SAN names supported for this enrollment type."""
    max_allowed_wildcard_san_names: NotRequired[Nullable[int]]
    r"""Maximum number of Wildcard SAN names supported for this enrollment type."""
    org: NotRequired[Nullable[GetEnrollmentOrgTypedDict]]
    r"""Your organization information."""
    org_id: NotRequired[Nullable[int]]
    r"""The Digicert unique identifier for the organization. If you use this value in a PUT or POST request, you can set the `org`, `techContact`, and `adminContact` values to `null`."""
    pending_changes: NotRequired[Nullable[List[GetEnrollmentPendingChangesTypedDict]]]
    r"""Returns the Changes currently pending in CPS. The last item in the array is the most recent change."""
    production_slots: NotRequired[Nullable[List[int]]]
    r"""Slots where the certificate is deployed on the production network."""
    signature_algorithm: NotRequired[Nullable[GetEnrollmentSignatureAlgorithm]]
    r"""Identifies the SHA (Secure Hash Algorithm) function. The NSA (National Security Agency) designed this function to produce a hash of certificate contents, for use in a digital signature. This is either `SHA-1` for a 160-bit (20-byte) hash or `SHA-256` for a 256-bit (32-byte) hash. To ensure a secure hash function, use `SHA-256`."""
    staging_slots: NotRequired[Nullable[List[int]]]
    r"""Slots where the certificate is deployed on the staging network."""
    tech_contact: NotRequired[Nullable[GetEnrollmentTechContactTypedDict]]
    r"""Contact information for an administrator at Akamai."""
    third_party: NotRequired[Nullable[GetEnrollmentThirdPartyTypedDict]]
    r"""Specifies that you want to use a third party certificate. This is any certificate that is not issued through CPS."""


class GetEnrollmentResponseBody(BaseModel):
    r"""An enrollment displays all the information about the process that your certificate goes through from the time you request it, through renewal, and as you obtain subsequent versions. CPS is a certificate life cycle management tool. Once you obtain a certificate, you use it until it expires, in most cases a year from the date the CA issued the certificate. CPS automatically starts the renewal process 90 days before the old certificate expires. It then automatically deploys the renewed certificate when it receives it from the CA."""

    certificate_type: Annotated[
        GetEnrollmentCertificateType, pydantic.Field(alias="certificateType")
    ]
    r"""Either `san`, `single`, `wildcard`, `wildcard-san`, or `third-party`. See [Enrollment.validationType Values](#validationtype) for details."""

    change_management: Annotated[bool, pydantic.Field(alias="changeManagement")]
    r"""Setting this to `true` for an enrollment stops CPS from deploying the certificate to the network until you acknowledge you're ready to deploy the certificate. You can test the certificate outside of CPS, on the Edge Staging Network (ESN), to make sure it works in your environment, and then deploy the certificate. The ESN is a small network of Akamai edge servers built to simulate Akamai's production network to test most of your site or application functionality with current production version configuration options and functions. For more information on the ESN, see the [Edge Staging Network User Guide](https://control.akamai.com/dl/customers/other/EDGESERV/ESN-User-Guide.pdf). You can also contact your account representative with questions or issues with your service on the ESN."""

    csr: GetEnrollmentCsr
    r"""When you create an enrollment, you also generate a certificate signing request (CSR) using CPS. CPS signs the CSR with the private key. The CSR contains all the information the CA needs to issue your certificate."""

    enable_multi_stacked_certificates: Annotated[
        bool, pydantic.Field(alias="enableMultiStackedCertificates")
    ]
    r"""Enable Dual-Stacked certificate deployment for this enrollment. The next renewal includes the change. Note that this value is only returned for third-party certificates. Otherwise it's omitted from the response."""

    network_configuration: Annotated[
        GetEnrollmentNetworkConfiguration, pydantic.Field(alias="networkConfiguration")
    ]
    r"""Settings that specify any network information and TLS Metadata you want CPS to use to push the completed certificate to the network."""

    ra: GetEnrollmentRa
    r"""The registration authority or certificate authority (CA) you want to use to obtain a certificate. A CA is a trusted entity that signs certificates and can vouch for the identity of a website. This is either `symantec`,  `lets-encrypt`, or `third-party`."""

    validation_type: Annotated[
        GetEnrollmentValidationType, pydantic.Field(alias="validationType")
    ]
    r"""CPS supports several types of validation: `dv`, `ev`, `ov`, or `third-party`. Domain Validation (`dv`) offers the lowest level of validation. The CA validates that you have control of the domain. CPS supports DV certificates issued by Let's Encrypt, a free, automated, and open CA, run for public benefit. Organization Validation (`ov`) offers the next level of validation. The CA validates that you have control of the domain. Extended Validation (`ev`) offers the highest level of validation, in which you need to have signed letters and notaries sent to the CA before signing. You can also specify `third-party` if you want to use a signed certificate you obtain from a CA that CPS doesn't directly support."""

    admin_contact: Annotated[
        OptionalNullable[GetEnrollmentAdminContact],
        pydantic.Field(alias="adminContact"),
    ] = UNSET
    r"""Contact information for the certificate administrator that you want to use as a contact at your company."""

    assigned_slots: Annotated[
        OptionalNullable[List[int]], pydantic.Field(alias="assignedSlots")
    ] = UNSET
    r"""Slots where the certificate is either deployed or is already deployed."""

    auto_renewal_start_time: Annotated[
        OptionalNullable[str], pydantic.Field(alias="autoRenewalStartTime")
    ] = UNSET
    r"""The specific date on which the renewal automatically starts for the enrollment."""

    certificate_chain_type: Annotated[
        OptionalNullable[GetEnrollmentCertificateChainType],
        pydantic.Field(alias="certificateChainType"),
    ] = UNSET
    r"""The kind of certificate trust chain. This is either `default` or `symantec1kroot`."""

    id: OptionalNullable[str|int] = UNSET
    r"""The unique identifier of the enrollment."""

    location: OptionalNullable[str] = UNSET
    r"""The URI path to the enrollment. The last segment of the URI path serves as a unique identifier for the enrollment."""

    max_allowed_san_names: Annotated[
        OptionalNullable[int], pydantic.Field(alias="maxAllowedSanNames")
    ] = UNSET
    r"""Maximum number of SAN names supported for this enrollment type."""

    max_allowed_wildcard_san_names: Annotated[
        OptionalNullable[int], pydantic.Field(alias="maxAllowedWildcardSanNames")
    ] = UNSET
    r"""Maximum number of Wildcard SAN names supported for this enrollment type."""

    org: OptionalNullable[GetEnrollmentOrg] = UNSET
    r"""Your organization information."""

    org_id: Annotated[OptionalNullable[int], pydantic.Field(alias="orgId")] = UNSET
    r"""The Digicert unique identifier for the organization. If you use this value in a PUT or POST request, you can set the `org`, `techContact`, and `adminContact` values to `null`."""

    pending_changes: Annotated[
        OptionalNullable[List[GetEnrollmentPendingChanges]],
        pydantic.Field(alias="pendingChanges"),
    ] = UNSET
    r"""Returns the Changes currently pending in CPS. The last item in the array is the most recent change."""

    production_slots: Annotated[
        OptionalNullable[List[int]], pydantic.Field(alias="productionSlots")
    ] = UNSET
    r"""Slots where the certificate is deployed on the production network."""

    signature_algorithm: Annotated[
        OptionalNullable[GetEnrollmentSignatureAlgorithm],
        pydantic.Field(alias="signatureAlgorithm"),
    ] = UNSET
    r"""Identifies the SHA (Secure Hash Algorithm) function. The NSA (National Security Agency) designed this function to produce a hash of certificate contents, for use in a digital signature. This is either `SHA-1` for a 160-bit (20-byte) hash or `SHA-256` for a 256-bit (32-byte) hash. To ensure a secure hash function, use `SHA-256`."""

    staging_slots: Annotated[
        OptionalNullable[List[int]], pydantic.Field(alias="stagingSlots")
    ] = UNSET
    r"""Slots where the certificate is deployed on the staging network."""

    tech_contact: Annotated[
        OptionalNullable[GetEnrollmentTechContact], pydantic.Field(alias="techContact")
    ] = UNSET
    r"""Contact information for an administrator at Akamai."""

    third_party: Annotated[
        OptionalNullable[GetEnrollmentThirdParty], pydantic.Field(alias="thirdParty")
    ] = UNSET
    r"""Specifies that you want to use a third party certificate. This is any certificate that is not issued through CPS."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "adminContact",
            "assignedSlots",
            "autoRenewalStartTime",
            "certificateChainType",
            "id",
            "location",
            "maxAllowedSanNames",
            "maxAllowedWildcardSanNames",
            "org",
            "orgId",
            "pendingChanges",
            "productionSlots",
            "signatureAlgorithm",
            "stagingSlots",
            "techContact",
            "thirdParty",
        ]
        nullable_fields = [
            "adminContact",
            "assignedSlots",
            "autoRenewalStartTime",
            "certificateChainType",
            "id",
            "location",
            "maxAllowedSanNames",
            "maxAllowedWildcardSanNames",
            "org",
            "orgId",
            "pendingChanges",
            "productionSlots",
            "signatureAlgorithm",
            "stagingSlots",
            "techContact",
            "thirdParty",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m
