"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from aktest_se.types import BaseModel, Nullable, OptionalNullable, UNSET, UNSET_SENTINEL
from aktest_se.utils import FieldMetadata, PathParamMetadata, QueryParamMetadata
import pydantic
from pydantic import model_serializer
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class GetDvHistoryRequestTypedDict(TypedDict):
    enrollment_id: int
    r"""Enrollment on which to perform the desired operation."""
    account_switch_key: NotRequired[str]
    r"""For customers who manage more than one account, this [runs the operation from another account](https://techdocs.akamai.com/developer/docs/manage-many-accounts-with-one-api-client). The Identity and Access Management API provides a [list of available account switch keys](https://techdocs.akamai.com/iam-api/reference/get-client-account-switch-keys)."""


class GetDvHistoryRequest(BaseModel):
    enrollment_id: Annotated[
        int,
        pydantic.Field(alias="enrollmentId"),
        FieldMetadata(path=PathParamMetadata(style="simple", explode=False)),
    ]
    r"""Enrollment on which to perform the desired operation."""

    account_switch_key: Annotated[
        Optional[str],
        pydantic.Field(alias="accountSwitchKey"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""For customers who manage more than one account, this [runs the operation from another account](https://techdocs.akamai.com/developer/docs/manage-many-accounts-with-one-api-client). The Identity and Access Management API provides a [list of available account switch keys](https://techdocs.akamai.com/iam-api/reference/get-client-account-switch-keys)."""


class GetDvHistoryEnrollmentsValidationRecordsTypedDict(TypedDict):
    authorities: List[str]
    r"""Validation authorities."""
    hostname: str
    r"""The name being validated."""
    port: str
    r"""Port used for validation."""
    resolved_ip: List[str]
    r"""IPs resolved for name being validated."""
    tried_ip: str
    r"""IP from `resolvedIp` tried for this validation."""
    url: str
    r"""URL attempted validated."""
    used_ip: str
    r"""IP from `resolvedIp` used for this validation."""


class GetDvHistoryEnrollmentsValidationRecords(BaseModel):
    authorities: List[str]
    r"""Validation authorities."""

    hostname: str
    r"""The name being validated."""

    port: str
    r"""Port used for validation."""

    resolved_ip: Annotated[List[str], pydantic.Field(alias="resolvedIp")]
    r"""IPs resolved for name being validated."""

    tried_ip: Annotated[str, pydantic.Field(alias="triedIp")]
    r"""IP from `resolvedIp` tried for this validation."""

    url: str
    r"""URL attempted validated."""

    used_ip: Annotated[str, pydantic.Field(alias="usedIp")]
    r"""IP from `resolvedIp` used for this validation."""


class GetDvHistoryChallengesTypedDict(TypedDict):
    validation_records: List[GetDvHistoryEnrollmentsValidationRecordsTypedDict]
    r"""The records that you send to Let's Encrypt to validate your domain."""
    error: NotRequired[Nullable[str]]
    r"""Validation status for this challenge."""
    full_path: NotRequired[str]
    r"""Path where Let's Encrypt respects and expects to find `token` as content."""
    redirect_full_path: NotRequired[str]
    r"""The URL where Akamai publishes `responseBody` for Let's Encrypt to validate `http-01` challenges. The client can configure a redirect at `fullPath` to redirect requests to this URL, keeping in mind that the token may change over time."""
    response_body: NotRequired[str]
    r"""The data Let's Encrypt expects to find served at `fullPath` URL."""
    status: NotRequired[str]
    r"""The domain validation status. Status include `valid` and `pending`."""
    token: NotRequired[str]
    r"""The validation token issued by Let's Encrypt."""
    type: NotRequired[str]
    r"""Challenge type. Current types include `http-01` and `dns-01`."""


class GetDvHistoryChallenges(BaseModel):
    validation_records: Annotated[
        List[GetDvHistoryEnrollmentsValidationRecords],
        pydantic.Field(alias="validationRecords"),
    ]
    r"""The records that you send to Let's Encrypt to validate your domain."""

    error: OptionalNullable[str] = UNSET
    r"""Validation status for this challenge."""

    full_path: Annotated[Optional[str], pydantic.Field(alias="fullPath")] = None
    r"""Path where Let's Encrypt respects and expects to find `token` as content."""

    redirect_full_path: Annotated[
        Optional[str], pydantic.Field(alias="redirectFullPath")
    ] = None
    r"""The URL where Akamai publishes `responseBody` for Let's Encrypt to validate `http-01` challenges. The client can configure a redirect at `fullPath` to redirect requests to this URL, keeping in mind that the token may change over time."""

    response_body: Annotated[Optional[str], pydantic.Field(alias="responseBody")] = None
    r"""The data Let's Encrypt expects to find served at `fullPath` URL."""

    status: Optional[str] = None
    r"""The domain validation status. Status include `valid` and `pending`."""

    token: Optional[str] = None
    r"""The validation token issued by Let's Encrypt."""

    type: Optional[str] = None
    r"""Challenge type. Current types include `http-01` and `dns-01`."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "error",
            "fullPath",
            "redirectFullPath",
            "responseBody",
            "status",
            "token",
            "type",
        ]
        nullable_fields = ["error"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetDvHistoryValidationRecordsTypedDict(TypedDict):
    hostname: str
    r"""The records that Let's Encrypt returns to you to validate your domain."""
    port: str
    r"""Port used for validation."""
    resolved_ip: List[str]
    r"""IPs resolved for name being validated."""
    url: str
    r"""URL attempted validated."""
    used_ip: str
    r"""IP from `resolvedIp` used for this validation."""


class GetDvHistoryValidationRecords(BaseModel):
    hostname: str
    r"""The records that Let's Encrypt returns to you to validate your domain."""

    port: str
    r"""Port used for validation."""

    resolved_ip: Annotated[List[str], pydantic.Field(alias="resolvedIp")]
    r"""IPs resolved for name being validated."""

    url: str
    r"""URL attempted validated."""

    used_ip: Annotated[str, pydantic.Field(alias="usedIp")]
    r"""IP from `resolvedIp` used for this validation."""


class DomainHistoryTypedDict(TypedDict):
    challenges: List[GetDvHistoryChallengesTypedDict]
    r"""Challenges used for validation."""
    validation_records: List[GetDvHistoryValidationRecordsTypedDict]
    r"""Validation attempts and status."""
    domain: NotRequired[str]
    r"""Domain which is being validated."""
    error: NotRequired[Nullable[str]]
    r"""Current validation status for domains not yet validated."""
    expires: NotRequired[str]
    r"""Timestamp when this token or validation expires. Sample 2017-12-05T18:57:07z."""
    full_path: NotRequired[str]
    r"""The URL that Let's Encrypt returns for the `token`."""
    redirect_full_path: NotRequired[str]
    r"""The URL that Let's Encrypt returns. This is the path to the server to which you want to redirect and find the token."""
    request_timestamp: NotRequired[str]
    r"""The timestamp when the domain was successfully requested. Sample 2014-08-12T18:57:07z."""
    response_body: NotRequired[str]
    r"""The data Let's Encrypt expects to find served at `fullPath` URL."""
    status: NotRequired[str]
    r"""The domain validation status."""
    token: NotRequired[str]
    r"""The validation token issued by Let's Encrypt."""
    validated_timestamp: NotRequired[str]
    r"""The timestamp when the domain was successfully validated. Sample 2014-08-12T18:57:07z."""
    validation_status: NotRequired[str]
    r"""Status of the domain validation process."""


class DomainHistory(BaseModel):
    challenges: List[GetDvHistoryChallenges]
    r"""Challenges used for validation."""

    validation_records: Annotated[
        List[GetDvHistoryValidationRecords], pydantic.Field(alias="validationRecords")
    ]
    r"""Validation attempts and status."""

    domain: Optional[str] = None
    r"""Domain which is being validated."""

    error: OptionalNullable[str] = UNSET
    r"""Current validation status for domains not yet validated."""

    expires: Optional[str] = None
    r"""Timestamp when this token or validation expires. Sample 2017-12-05T18:57:07z."""

    full_path: Annotated[Optional[str], pydantic.Field(alias="fullPath")] = None
    r"""The URL that Let's Encrypt returns for the `token`."""

    redirect_full_path: Annotated[
        Optional[str], pydantic.Field(alias="redirectFullPath")
    ] = None
    r"""The URL that Let's Encrypt returns. This is the path to the server to which you want to redirect and find the token."""

    request_timestamp: Annotated[
        Optional[str], pydantic.Field(alias="requestTimestamp")
    ] = None
    r"""The timestamp when the domain was successfully requested. Sample 2014-08-12T18:57:07z."""

    response_body: Annotated[Optional[str], pydantic.Field(alias="responseBody")] = None
    r"""The data Let's Encrypt expects to find served at `fullPath` URL."""

    status: Optional[str] = None
    r"""The domain validation status."""

    token: Optional[str] = None
    r"""The validation token issued by Let's Encrypt."""

    validated_timestamp: Annotated[
        Optional[str], pydantic.Field(alias="validatedTimestamp")
    ] = None
    r"""The timestamp when the domain was successfully validated. Sample 2014-08-12T18:57:07z."""

    validation_status: Annotated[
        Optional[str], pydantic.Field(alias="validationStatus")
    ] = None
    r"""Status of the domain validation process."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "domain",
            "error",
            "expires",
            "fullPath",
            "redirectFullPath",
            "requestTimestamp",
            "responseBody",
            "status",
            "token",
            "validatedTimestamp",
            "validationStatus",
        ]
        nullable_fields = ["error"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class ResultsTypedDict(TypedDict):
    domain: str
    r"""The domain being validated."""
    domain_history: List[DomainHistoryTypedDict]
    r"""A history record for a single domain."""


class Results(BaseModel):
    domain: str
    r"""The domain being validated."""

    domain_history: Annotated[
        List[DomainHistory], pydantic.Field(alias="domainHistory")
    ]
    r"""A history record for a single domain."""


class GetDvHistoryResponseBodyTypedDict(TypedDict):
    r"""If you use domain validation, the CA that issued the certificate validates that you have control of the domain. CPS supports DV certificates issued by Let's Encrypt, an automated, and open CA, run for public benefit. Use the domain validation history to view your Akamai managed DV certificates' history and errors. These certificates expire in 90 days."""

    results: List[ResultsTypedDict]
    r"""Domain Validation (DV) challenges are used by Let's Encrypt to verify domain control."""


class GetDvHistoryResponseBody(BaseModel):
    r"""If you use domain validation, the CA that issued the certificate validates that you have control of the domain. CPS supports DV certificates issued by Let's Encrypt, an automated, and open CA, run for public benefit. Use the domain validation history to view your Akamai managed DV certificates' history and errors. These certificates expire in 90 days."""

    results: List[Results]
    r"""Domain Validation (DV) challenges are used by Let's Encrypt to verify domain control."""
