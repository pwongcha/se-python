"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from aktest_se.types import BaseModel, Nullable, OptionalNullable, UNSET, UNSET_SENTINEL
from aktest_se.utils import FieldMetadata, PathParamMetadata, QueryParamMetadata
from enum import Enum
import pydantic
from pydantic import model_serializer
from typing import List, Optional, Union
from typing_extensions import Annotated, NotRequired, TypedDict


class AllowedInputTypeParam(str, Enum):
    r"""__Enum__ Found as the last part of `Change.allowedInput[].update` hypermedia URL. See [Change Input Content Type Mapping](ref:change-input-content-type-mapping) for details. Currently supported values include `change-management-info`, `lets-encrypt-challenges`, `post-verification-warnings`, `pre-verification-warnings`, `third-party-csr`."""

    CHANGE_MANAGEMENT_INFO = "change-management-info"
    LETS_ENCRYPT_CHALLENGES = "lets-encrypt-challenges"
    POST_VERIFICATION_WARNINGS = "post-verification-warnings"
    PRE_VERIFICATION_WARNINGS = "pre-verification-warnings"
    THIRD_PARTY_CSR = "third-party-csr"


class GetChangeAllowedInputParamRequestTypedDict(TypedDict):
    allowed_input_type_param: AllowedInputTypeParam
    r"""__Enum__ Found as the last part of `Change.allowedInput[].update` hypermedia URL. See [Change Input Content Type Mapping](ref:change-input-content-type-mapping) for details. Currently supported values include `change-management-info`, `lets-encrypt-challenges`, `post-verification-warnings`, `pre-verification-warnings`, `third-party-csr`."""
    change_id: int
    r"""The change for this enrollment on which to perform the desired operation."""
    enrollment_id: int
    r"""Enrollment on which to perform the desired operation."""
    account_switch_key: NotRequired[str]
    r"""For customers who manage more than one account, this [runs the operation from another account](https://techdocs.akamai.com/developer/docs/manage-many-accounts-with-one-api-client). The Identity and Access Management API provides a [list of available account switch keys](https://techdocs.akamai.com/iam-api/reference/get-client-account-switch-keys)."""


class GetChangeAllowedInputParamRequest(BaseModel):
    allowed_input_type_param: Annotated[
        AllowedInputTypeParam,
        pydantic.Field(alias="allowedInputTypeParam"),
        FieldMetadata(path=PathParamMetadata(style="simple", explode=False)),
    ]
    r"""__Enum__ Found as the last part of `Change.allowedInput[].update` hypermedia URL. See [Change Input Content Type Mapping](ref:change-input-content-type-mapping) for details. Currently supported values include `change-management-info`, `lets-encrypt-challenges`, `post-verification-warnings`, `pre-verification-warnings`, `third-party-csr`."""

    change_id: Annotated[
        int,
        pydantic.Field(alias="changeId"),
        FieldMetadata(path=PathParamMetadata(style="simple", explode=False)),
    ]
    r"""The change for this enrollment on which to perform the desired operation."""

    enrollment_id: Annotated[
        int,
        pydantic.Field(alias="enrollmentId"),
        FieldMetadata(path=PathParamMetadata(style="simple", explode=False)),
    ]
    r"""Enrollment on which to perform the desired operation."""

    account_switch_key: Annotated[
        Optional[str],
        pydantic.Field(alias="accountSwitchKey"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""For customers who manage more than one account, this [runs the operation from another account](https://techdocs.akamai.com/developer/docs/manage-many-accounts-with-one-api-client). The Identity and Access Management API provides a [list of available account switch keys](https://techdocs.akamai.com/iam-api/reference/get-client-account-switch-keys)."""


class GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsWarningsV1PlusJSONResponseBodyTypedDict(
    TypedDict
):
    r"""Warnings generated by CPS."""

    warnings: str
    r"""String with comma separated list of warnings."""


class GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsWarningsV1PlusJSONResponseBody(
    BaseModel
):
    r"""Warnings generated by CPS."""

    warnings: str
    r"""String with comma separated list of warnings."""


class GetChangeAllowedInputParamStatus(str, Enum):
    r"""The domain validation status. Current values include `Preparing`, `Pending`, `Awaiting user`, `Valid`, `Invalid`, `Error` & `Ready for Validation`."""

    PREPARING = "Preparing"
    PENDING = "Pending"
    AWAITING_USER = "Awaiting user"
    VALID = "Valid"
    INVALID = "Invalid"
    ERROR = "Error"
    READY_FOR_VALIDATION = "Ready for Validation"


class GetChangeAllowedInputParamType(str, Enum):
    r"""Validation type. Either `dns-01` or `http-01`."""

    DNS_01 = "dns-01"
    HTTP_01 = "http-01"


class ValidationRecordsTypedDict(TypedDict):
    authorities: List[str]
    r"""Validation authorities."""
    hostname: str
    r"""Domain name being validated."""
    port: str
    r"""Port used for validation."""
    resolved_ip: List[str]
    r"""IPs resolved for name being validated."""
    tried_ip: str
    r"""IP from `resolvedIp` tried for this validation."""
    url: str
    r"""URL attempted validated."""
    used_ip: str
    r"""IP from `resolvedIp` used for this validation."""


class ValidationRecords(BaseModel):
    authorities: List[str]
    r"""Validation authorities."""

    hostname: str
    r"""Domain name being validated."""

    port: str
    r"""Port used for validation."""

    resolved_ip: Annotated[List[str], pydantic.Field(alias="resolvedIp")]
    r"""IPs resolved for name being validated."""

    tried_ip: Annotated[str, pydantic.Field(alias="triedIp")]
    r"""IP from `resolvedIp` tried for this validation."""

    url: str
    r"""URL attempted validated."""

    used_ip: Annotated[str, pydantic.Field(alias="usedIp")]
    r"""IP from `resolvedIp` used for this validation."""


class GetChangeAllowedInputParamChallengesTypedDict(TypedDict):
    validation_records: List[ValidationRecordsTypedDict]
    r"""Validation attempts and status."""
    error: NotRequired[Nullable[str]]
    r"""Error message describing failure to validate domain control."""
    full_path: NotRequired[str]
    r"""URL where Let's Encrypt requests and expects to find 'token' as content."""
    redirect_full_path: NotRequired[str]
    r"""The URL where Akamai publishes `responseBody` for Let's Encrypt to validate. The client can configure a redirect at `fullPath` to redirect requests to this URL, keeping in mind that the token may change over time."""
    response_body: NotRequired[str]
    r"""The data Let's Encrypt expects to find served at `fullPath` URL."""
    status: NotRequired[GetChangeAllowedInputParamStatus]
    r"""The domain validation status. Current values include `Preparing`, `Pending`, `Awaiting user`, `Valid`, `Invalid`, `Error` & `Ready for Validation`."""
    token: NotRequired[str]
    r"""The validation token issued by Let's Encrypt."""
    type: NotRequired[GetChangeAllowedInputParamType]
    r"""Validation type. Either `dns-01` or `http-01`."""


class GetChangeAllowedInputParamChallenges(BaseModel):
    validation_records: Annotated[
        List[ValidationRecords], pydantic.Field(alias="validationRecords")
    ]
    r"""Validation attempts and status."""

    error: OptionalNullable[str] = UNSET
    r"""Error message describing failure to validate domain control."""

    full_path: Annotated[Optional[str], pydantic.Field(alias="fullPath")] = None
    r"""URL where Let's Encrypt requests and expects to find 'token' as content."""

    redirect_full_path: Annotated[
        Optional[str], pydantic.Field(alias="redirectFullPath")
    ] = None
    r"""The URL where Akamai publishes `responseBody` for Let's Encrypt to validate. The client can configure a redirect at `fullPath` to redirect requests to this URL, keeping in mind that the token may change over time."""

    response_body: Annotated[Optional[str], pydantic.Field(alias="responseBody")] = None
    r"""The data Let's Encrypt expects to find served at `fullPath` URL."""

    status: Optional[GetChangeAllowedInputParamStatus] = None
    r"""The domain validation status. Current values include `Preparing`, `Pending`, `Awaiting user`, `Valid`, `Invalid`, `Error` & `Ready for Validation`."""

    token: Optional[str] = None
    r"""The validation token issued by Let's Encrypt."""

    type: Optional[GetChangeAllowedInputParamType] = None
    r"""Validation type. Either `dns-01` or `http-01`."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "error",
            "fullPath",
            "redirectFullPath",
            "responseBody",
            "status",
            "token",
            "type",
        ]
        nullable_fields = ["error"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class DvTypedDict(TypedDict):
    challenges: List[GetChangeAllowedInputParamChallengesTypedDict]
    r"""Domains that need to be validated for this Enrollment. V1 only supports and displays http-01 challenge. V2 allows HTTP and DNS challenge types. Each domain in the enrollment can have many challenges and can use a different challenge types. To validate a domain, only one challenge for each domain needs to be complete."""
    domain: NotRequired[str]
    r"""Domain which is being validated."""
    error: NotRequired[Nullable[str]]
    r"""Current validation status for domains not yet validated."""
    expires: NotRequired[str]
    r"""Timestamp when this token or validation expires. Sample 2017-12-05T18:57:07z."""
    request_timestamp: NotRequired[str]
    r"""Timestamp Akamai received validation token from Let's Encrypt. Sample `2017-12-12T18:57:07z`."""
    status: NotRequired[str]
    r"""Let's Encrypt validation status. Required `Valid` for certificate generation."""
    validated_timestamp: NotRequired[str]
    r"""Timestamp when domain was successfully validated. Sample 2017-12-12T18:57:07z."""
    validation_status: NotRequired[str]
    r"""Status of the domain validation process."""


class Dv(BaseModel):
    challenges: List[GetChangeAllowedInputParamChallenges]
    r"""Domains that need to be validated for this Enrollment. V1 only supports and displays http-01 challenge. V2 allows HTTP and DNS challenge types. Each domain in the enrollment can have many challenges and can use a different challenge types. To validate a domain, only one challenge for each domain needs to be complete."""

    domain: Optional[str] = None
    r"""Domain which is being validated."""

    error: OptionalNullable[str] = UNSET
    r"""Current validation status for domains not yet validated."""

    expires: Optional[str] = None
    r"""Timestamp when this token or validation expires. Sample 2017-12-05T18:57:07z."""

    request_timestamp: Annotated[
        Optional[str], pydantic.Field(alias="requestTimestamp")
    ] = None
    r"""Timestamp Akamai received validation token from Let's Encrypt. Sample `2017-12-12T18:57:07z`."""

    status: Optional[str] = None
    r"""Let's Encrypt validation status. Required `Valid` for certificate generation."""

    validated_timestamp: Annotated[
        Optional[str], pydantic.Field(alias="validatedTimestamp")
    ] = None
    r"""Timestamp when domain was successfully validated. Sample 2017-12-12T18:57:07z."""

    validation_status: Annotated[
        Optional[str], pydantic.Field(alias="validationStatus")
    ] = None
    r"""Status of the domain validation process."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "domain",
            "error",
            "expires",
            "requestTimestamp",
            "status",
            "validatedTimestamp",
            "validationStatus",
        ]
        nullable_fields = ["error"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsDvChallengesV2PlusJSONResponseBodyTypedDict(
    TypedDict
):
    r"""When using certificates with domain validation, you prove that you have control over each of the domains listed in the certificate. When you create a new DV enrollment that generates a certificate signing request (CSR), CPS automatically sends it to Let's Encrypt for signing. Let's Encrypt sends back a challenge for each domain listed on your certificate. You prove that you have control over the domains listed in the CSR by redirecting your traffic to Akamai, or placing a token in the domain's DNS zone. This allows Akamai to complete the challenge process for you by detecting the redirect or DNS token, and answering Let's Encrypt's challenge. You need to complete one of the challenges for each domain to validate the certificate. To validate a domain, only one challenge for each domain needs to be complete. Let's Encrypt automatically verifies the domain after it receives an answer to the challenge, and marks the domain as validated."""

    dv: List[DvTypedDict]
    r"""Domain validation entities returned in query parameters."""


class GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsDvChallengesV2PlusJSONResponseBody(
    BaseModel
):
    r"""When using certificates with domain validation, you prove that you have control over each of the domains listed in the certificate. When you create a new DV enrollment that generates a certificate signing request (CSR), CPS automatically sends it to Let's Encrypt for signing. Let's Encrypt sends back a challenge for each domain listed on your certificate. You prove that you have control over the domains listed in the CSR by redirecting your traffic to Akamai, or placing a token in the domain's DNS zone. This allows Akamai to complete the challenge process for you by detecting the redirect or DNS token, and answering Let's Encrypt's challenge. You need to complete one of the challenges for each domain to validate the certificate. To validate a domain, only one challenge for each domain needs to be complete. Let's Encrypt automatically verifies the domain after it receives an answer to the challenge, and marks the domain as validated."""

    dv: List[Dv]
    r"""Domain validation entities returned in query parameters."""


class ChallengesTypedDict(TypedDict):
    domain: str
    r"""Domain which is being validated."""
    error: Nullable[str]
    r"""Current validation status for domains not yet validated."""
    expires: str
    r"""Timestamp when this token or validation expires. Sample 2014-08-12T18:57:07z."""
    full_path: str
    r"""URL where Let's Encrypt requests and expects to find 'token' as content."""
    redirect_full_path: str
    r"""The URL where Akamai publishes `responseBody` for Let's Encrypt to validate. The client can configure a redirect at `fullPath` to redirect requests to this URL, keeping in mind that the token may change over time."""
    request_timestamp: str
    r"""Timestamp Akamai received validation token from Let's Encrypt. Sample `2014-08-12T18:57:07z`."""
    response_body: str
    r"""The data Let's Encrypt expects to find served at `fullPath` URL."""
    status: str
    r"""The domain validation status."""
    token: str
    r"""The validation token issued by Let's Encrypt."""
    validated_timestamp: str
    r"""Timestamp when domain was successfully validated. Sample 2014-08-12T18:57:07z."""


class Challenges(BaseModel):
    domain: str
    r"""Domain which is being validated."""

    error: Nullable[str]
    r"""Current validation status for domains not yet validated."""

    expires: str
    r"""Timestamp when this token or validation expires. Sample 2014-08-12T18:57:07z."""

    full_path: Annotated[str, pydantic.Field(alias="fullPath")]
    r"""URL where Let's Encrypt requests and expects to find 'token' as content."""

    redirect_full_path: Annotated[str, pydantic.Field(alias="redirectFullPath")]
    r"""The URL where Akamai publishes `responseBody` for Let's Encrypt to validate. The client can configure a redirect at `fullPath` to redirect requests to this URL, keeping in mind that the token may change over time."""

    request_timestamp: Annotated[str, pydantic.Field(alias="requestTimestamp")]
    r"""Timestamp Akamai received validation token from Let's Encrypt. Sample `2014-08-12T18:57:07z`."""

    response_body: Annotated[str, pydantic.Field(alias="responseBody")]
    r"""The data Let's Encrypt expects to find served at `fullPath` URL."""

    status: str
    r"""The domain validation status."""

    token: str
    r"""The validation token issued by Let's Encrypt."""

    validated_timestamp: Annotated[str, pydantic.Field(alias="validatedTimestamp")]
    r"""Timestamp when domain was successfully validated. Sample 2014-08-12T18:57:07z."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["error"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsDvChallengesV1PlusJSONResponseBodyTypedDict(
    TypedDict
):
    r"""When using certificates with domain validation, you prove that you have control over each of the domains listed in the certificate. When you create a new DV enrollment that generates a certificate signing request (CSR), CPS automatically sends it to Let's Encrypt for signing. Let's Encrypt sends back a challenge for each domain listed on your certificate. You prove that you have control over the domains listed in the CSR by redirecting your traffic to Akamai. This allows Akamai to complete the challenge process for you by detecting the redirect and answering Let's Encrypt's challenge. You need to configure your web server to redirect your traffic to Akamai. If you aren't able to redirect traffic on your web server, you need to instruct the person who can redirect traffic to do so. Let's Encrypt automatically verifies the domain after it receives an answer to the challenge, and marks the domain as validated. A version label indicates this member is introduced in that version. A pre-version label indicates this member is removed in that version. No version label indicates this member is present in all versions."""

    challenges: List[ChallengesTypedDict]
    r"""Domains that need to be validated for this Enrollment. V1 only supports and displays http-01 challenge."""


class GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsDvChallengesV1PlusJSONResponseBody(
    BaseModel
):
    r"""When using certificates with domain validation, you prove that you have control over each of the domains listed in the certificate. When you create a new DV enrollment that generates a certificate signing request (CSR), CPS automatically sends it to Let's Encrypt for signing. Let's Encrypt sends back a challenge for each domain listed on your certificate. You prove that you have control over the domains listed in the CSR by redirecting your traffic to Akamai. This allows Akamai to complete the challenge process for you by detecting the redirect and answering Let's Encrypt's challenge. You need to configure your web server to redirect your traffic to Akamai. If you aren't able to redirect traffic on your web server, you need to instruct the person who can redirect traffic to do so. Let's Encrypt automatically verifies the domain after it receives an answer to the challenge, and marks the domain as validated. A version label indicates this member is introduced in that version. A pre-version label indicates this member is removed in that version. No version label indicates this member is present in all versions."""

    challenges: List[Challenges]
    r"""Domains that need to be validated for this Enrollment. V1 only supports and displays http-01 challenge."""


class GetChangeAllowedInputParamChangesResponseKeyAlgorithm(str, Enum):
    r"""The key algorithm of the certificate. This is either `ECDSA` or `RSA`."""

    ECDSA = "ECDSA"
    RSA = "RSA"


class GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsDeploymentV8PlusJSONSignatureAlgorithm(
    str, Enum
):
    r"""Indicates the SHA (Secure Hash Algorithm) function. You can use either `SHA-1` for a 160-bit (20-byte) hash or `SHA-256` for a 256-bit (32-byte) hash."""

    SHA_1 = "SHA-1"
    SHA_256 = "SHA-256"


class GetChangeAllowedInputParamChangesMultiStackedCertificatesTypedDict(TypedDict):
    certificate: Nullable[str]
    r"""The certificate text."""
    trust_chain: Nullable[str]
    r"""The trust chain for the certificate."""
    expiry: NotRequired[str]
    r"""The expiration date for the certificate."""
    key_algorithm: NotRequired[GetChangeAllowedInputParamChangesResponseKeyAlgorithm]
    r"""The key algorithm of the certificate. This is either `ECDSA` or `RSA`."""
    signature_algorithm: NotRequired[
        Nullable[
            GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsDeploymentV8PlusJSONSignatureAlgorithm
        ]
    ]
    r"""Indicates the SHA (Secure Hash Algorithm) function. You can use either `SHA-1` for a 160-bit (20-byte) hash or `SHA-256` for a 256-bit (32-byte) hash."""


class GetChangeAllowedInputParamChangesMultiStackedCertificates(BaseModel):
    certificate: Nullable[str]
    r"""The certificate text."""

    trust_chain: Annotated[Nullable[str], pydantic.Field(alias="trustChain")]
    r"""The trust chain for the certificate."""

    expiry: Optional[str] = None
    r"""The expiration date for the certificate."""

    key_algorithm: Annotated[
        Optional[GetChangeAllowedInputParamChangesResponseKeyAlgorithm],
        pydantic.Field(alias="keyAlgorithm"),
    ] = None
    r"""The key algorithm of the certificate. This is either `ECDSA` or `RSA`."""

    signature_algorithm: Annotated[
        OptionalNullable[
            GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsDeploymentV8PlusJSONSignatureAlgorithm
        ],
        pydantic.Field(alias="signatureAlgorithm"),
    ] = UNSET
    r"""Indicates the SHA (Secure Hash Algorithm) function. You can use either `SHA-1` for a 160-bit (20-byte) hash or `SHA-256` for a 256-bit (32-byte) hash."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["expiry", "keyAlgorithm", "signatureAlgorithm"]
        nullable_fields = ["certificate", "trustChain", "signatureAlgorithm"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetChangeAllowedInputParamChangesResponse200Geography(str, Enum):
    r"""Specifies the type of network where you want to deploy your certificate.  Use `core` to deploy across most of the world except for specially licensed areas.  Use `china+core` to include China, or `russia+core` to include Russia. Any non-`core` deployment needs to be enabled on your contract based on approval from the Chinese or Russian governments."""

    CORE = "core"
    CHINA_PLUS_CORE = "china+core"
    RUSSIA_PLUS_CORE = "russia+core"


class GetChangeAllowedInputParamChangesOcspStapling(str, Enum):
    r"""Indicates the OCSP stapling setting for the deployment. Use `on` to enable OCSP stapling, `off` to disable it, or `not-set` to ignore it."""

    ON = "on"
    OFF = "off"
    NOT_SET = "not-set"


class GetChangeAllowedInputParamChangesSecureNetwork(str, Enum):
    r"""Identifies the type of deployment network. An `enhanced-tls` value means Akamai's more secure network with PCI compliance capability, while `standard-tls` means Akamai's standard secure network."""

    ENHANCED_TLS = "enhanced-tls"
    STANDARD_TLS = "standard-tls"


class GetChangeAllowedInputParamChangesResponse200NetworkConfigurationTypedDict(
    TypedDict
):
    r"""Network configuration properties."""

    quic_enabled: bool
    r"""QUIC transport layer network protocol."""
    sni_only: bool
    r"""Server Name Indication (SNI) is an extension of the Transport Layer Security (TLS) networking protocol. It allows a server to present many certificates on the same IP address. All modern web browsers support the SNI extension. If you have the same SAN on two or more certificates with the SNI-only option set, Akamai may serve traffic using any certificate which matches the requested SNI hostname. You should avoid any certificates with overlapping SAN names when using SNI-only."""
    disallowed_tls_versions: NotRequired[List[str]]
    r"""Disallowed TLS protocol."""
    dns_names: NotRequired[List[str]]
    r"""Names served by SNI-only enabled enrollments."""
    fips_mode: NotRequired[bool]
    r"""Enables Federal Information Processing Standards (FIPS) for the enrollment."""
    geography: NotRequired[GetChangeAllowedInputParamChangesResponse200Geography]
    r"""Specifies the type of network where you want to deploy your certificate.  Use `core` to deploy across most of the world except for specially licensed areas.  Use `china+core` to include China, or `russia+core` to include Russia. Any non-`core` deployment needs to be enabled on your contract based on approval from the Chinese or Russian governments."""
    must_have_ciphers: NotRequired[str]
    r"""Ciphers that you definitely want to include for your enrollment while deploying it on the network. For more information on cipher profiles, see [Update SSL/TLS cipher profiles](doc:cipher-profiles)."""
    ocsp_stapling: NotRequired[GetChangeAllowedInputParamChangesOcspStapling]
    r"""Indicates the OCSP stapling setting for the deployment. Use `on` to enable OCSP stapling, `off` to disable it, or `not-set` to ignore it."""
    preferred_ciphers: NotRequired[str]
    r"""Ciphers that you preferably want to include for your enrollment while deploying it on the network. For more information on cipher profiles, see [Update SSL/TLS cipher profiles](doc:cipher-profiles)."""
    secure_network: NotRequired[GetChangeAllowedInputParamChangesSecureNetwork]
    r"""Identifies the type of deployment network. An `enhanced-tls` value means Akamai's more secure network with PCI compliance capability, while `standard-tls` means Akamai's standard secure network."""


class GetChangeAllowedInputParamChangesResponse200NetworkConfiguration(BaseModel):
    r"""Network configuration properties."""

    quic_enabled: Annotated[bool, pydantic.Field(alias="quicEnabled")]
    r"""QUIC transport layer network protocol."""

    sni_only: Annotated[bool, pydantic.Field(alias="sniOnly")]
    r"""Server Name Indication (SNI) is an extension of the Transport Layer Security (TLS) networking protocol. It allows a server to present many certificates on the same IP address. All modern web browsers support the SNI extension. If you have the same SAN on two or more certificates with the SNI-only option set, Akamai may serve traffic using any certificate which matches the requested SNI hostname. You should avoid any certificates with overlapping SAN names when using SNI-only."""

    disallowed_tls_versions: Annotated[
        Optional[List[str]], pydantic.Field(alias="disallowedTlsVersions")
    ] = None
    r"""Disallowed TLS protocol."""

    dns_names: Annotated[Optional[List[str]], pydantic.Field(alias="dnsNames")] = None
    r"""Names served by SNI-only enabled enrollments."""

    fips_mode: Annotated[Optional[bool], pydantic.Field(alias="fipsMode")] = None
    r"""Enables Federal Information Processing Standards (FIPS) for the enrollment."""

    geography: Optional[GetChangeAllowedInputParamChangesResponse200Geography] = None
    r"""Specifies the type of network where you want to deploy your certificate.  Use `core` to deploy across most of the world except for specially licensed areas.  Use `china+core` to include China, or `russia+core` to include Russia. Any non-`core` deployment needs to be enabled on your contract based on approval from the Chinese or Russian governments."""

    must_have_ciphers: Annotated[
        Optional[str], pydantic.Field(alias="mustHaveCiphers")
    ] = None
    r"""Ciphers that you definitely want to include for your enrollment while deploying it on the network. For more information on cipher profiles, see [Update SSL/TLS cipher profiles](doc:cipher-profiles)."""

    ocsp_stapling: Annotated[
        Optional[GetChangeAllowedInputParamChangesOcspStapling],
        pydantic.Field(alias="ocspStapling"),
    ] = None
    r"""Indicates the OCSP stapling setting for the deployment. Use `on` to enable OCSP stapling, `off` to disable it, or `not-set` to ignore it."""

    preferred_ciphers: Annotated[
        Optional[str], pydantic.Field(alias="preferredCiphers")
    ] = None
    r"""Ciphers that you preferably want to include for your enrollment while deploying it on the network. For more information on cipher profiles, see [Update SSL/TLS cipher profiles](doc:cipher-profiles)."""

    secure_network: Annotated[
        Optional[GetChangeAllowedInputParamChangesSecureNetwork],
        pydantic.Field(alias="secureNetwork"),
    ] = None
    r"""Identifies the type of deployment network. An `enhanced-tls` value means Akamai's more secure network with PCI compliance capability, while `standard-tls` means Akamai's standard secure network."""


class GetChangeAllowedInputParamChangesResponse200KeyAlgorithm(str, Enum):
    r"""The key algorithm for the multi-stacked certificate. This is either `ECDSA` or `RSA`."""

    ECDSA = "ECDSA"
    RSA = "RSA"


class GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsDeploymentV8PlusJSONResponseBodySignatureAlgorithm(
    str, Enum
):
    r"""Identifies the SHA (Secure Hash Algorithm) function. The NSA (National Security Agency) designed this function to produce a hash of certificate contents, which is used in a digital signature. This is either `SHA-1` for a 160-bit (20-byte) hash or `SHA-256` for a 256-bit (32-byte) hash. To ensure a secure hash function, use `SHA-256`."""

    SHA_1 = "SHA-1"
    SHA_256 = "SHA-256"


class GetChangeAllowedInputParamChangesPrimaryCertificateTypedDict(TypedDict):
    r"""Primary certificate of the enrollment."""

    certificate: Nullable[str]
    r"""The certificate text."""
    trust_chain: Nullable[str]
    r"""The trust chain for the certificate."""
    expiry: NotRequired[str]
    r"""The expiration date for the certificate."""
    key_algorithm: NotRequired[GetChangeAllowedInputParamChangesResponse200KeyAlgorithm]
    r"""The key algorithm for the multi-stacked certificate. This is either `ECDSA` or `RSA`."""
    signature_algorithm: NotRequired[
        Nullable[
            GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsDeploymentV8PlusJSONResponseBodySignatureAlgorithm
        ]
    ]
    r"""Identifies the SHA (Secure Hash Algorithm) function. The NSA (National Security Agency) designed this function to produce a hash of certificate contents, which is used in a digital signature. This is either `SHA-1` for a 160-bit (20-byte) hash or `SHA-256` for a 256-bit (32-byte) hash. To ensure a secure hash function, use `SHA-256`."""


class GetChangeAllowedInputParamChangesPrimaryCertificate(BaseModel):
    r"""Primary certificate of the enrollment."""

    certificate: Nullable[str]
    r"""The certificate text."""

    trust_chain: Annotated[Nullable[str], pydantic.Field(alias="trustChain")]
    r"""The trust chain for the certificate."""

    expiry: Optional[str] = None
    r"""The expiration date for the certificate."""

    key_algorithm: Annotated[
        Optional[GetChangeAllowedInputParamChangesResponse200KeyAlgorithm],
        pydantic.Field(alias="keyAlgorithm"),
    ] = None
    r"""The key algorithm for the multi-stacked certificate. This is either `ECDSA` or `RSA`."""

    signature_algorithm: Annotated[
        OptionalNullable[
            GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsDeploymentV8PlusJSONResponseBodySignatureAlgorithm
        ],
        pydantic.Field(alias="signatureAlgorithm"),
    ] = UNSET
    r"""Identifies the SHA (Secure Hash Algorithm) function. The NSA (National Security Agency) designed this function to produce a hash of certificate contents, which is used in a digital signature. This is either `SHA-1` for a 160-bit (20-byte) hash or `SHA-256` for a 256-bit (32-byte) hash. To ensure a secure hash function, use `SHA-256`."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["expiry", "keyAlgorithm", "signatureAlgorithm"]
        nullable_fields = ["certificate", "trustChain", "signatureAlgorithm"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsDeploymentV8PlusJSONResponseBodyTypedDict(
    TypedDict
):
    r"""Deploys your certificate to a network."""

    multi_stacked_certificates: List[
        GetChangeAllowedInputParamChangesMultiStackedCertificatesTypedDict
    ]
    r"""Dual-stacked certificates today include an ECDSA certificate in addition to an RSA certificate. Deployment may include many dual-stacked certificates."""
    network_configuration: (
        GetChangeAllowedInputParamChangesResponse200NetworkConfigurationTypedDict
    )
    r"""Network configuration properties."""
    primary_certificate: Nullable[
        GetChangeAllowedInputParamChangesPrimaryCertificateTypedDict
    ]
    r"""Primary certificate of the enrollment."""
    ocsp_stapled: NotRequired[bool]
    r"""OCSP Stapling improves performance by including a valid OCSP response in every TLS handshake. You should enable this feature."""
    ocsp_uris: NotRequired[Nullable[List[str]]]
    r"""URI used for OCSP stapling validation."""


class GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsDeploymentV8PlusJSONResponseBody(
    BaseModel
):
    r"""Deploys your certificate to a network."""

    multi_stacked_certificates: Annotated[
        List[GetChangeAllowedInputParamChangesMultiStackedCertificates],
        pydantic.Field(alias="multiStackedCertificates"),
    ]
    r"""Dual-stacked certificates today include an ECDSA certificate in addition to an RSA certificate. Deployment may include many dual-stacked certificates."""

    network_configuration: Annotated[
        GetChangeAllowedInputParamChangesResponse200NetworkConfiguration,
        pydantic.Field(alias="networkConfiguration"),
    ]
    r"""Network configuration properties."""

    primary_certificate: Annotated[
        Nullable[GetChangeAllowedInputParamChangesPrimaryCertificate],
        pydantic.Field(alias="primaryCertificate"),
    ]
    r"""Primary certificate of the enrollment."""

    ocsp_stapled: Annotated[Optional[bool], pydantic.Field(alias="ocspStapled")] = None
    r"""OCSP Stapling improves performance by including a valid OCSP response in every TLS handshake. You should enable this feature."""

    ocsp_uris: Annotated[
        OptionalNullable[List[str]], pydantic.Field(alias="ocspUris")
    ] = UNSET
    r"""URI used for OCSP stapling validation."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["ocspStapled", "ocspUris"]
        nullable_fields = ["primaryCertificate", "ocspUris"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetChangeAllowedInputParamKeyAlgorithm(str, Enum):
    r"""The key algorithm of the certificate. This is either `ECDSA` or `RSA`."""

    ECDSA = "ECDSA"
    RSA = "RSA"


class GetChangeAllowedInputParamChangesResponse200SignatureAlgorithm(str, Enum):
    r"""Indicates the SHA (Secure Hash Algorithm) function. You can use either `SHA-1` for a 160-bit (20-byte) hash or `SHA-256` for a 256-bit (32-byte) hash."""

    SHA_1 = "SHA-1"
    SHA_256 = "SHA-256"


class GetChangeAllowedInputParamMultiStackedCertificatesTypedDict(TypedDict):
    certificate: Nullable[str]
    r"""The certificate text."""
    trust_chain: Nullable[str]
    r"""The trust chain for the certificate."""
    expiry: NotRequired[str]
    r"""The expiration date for the certificate."""
    key_algorithm: NotRequired[GetChangeAllowedInputParamKeyAlgorithm]
    r"""The key algorithm of the certificate. This is either `ECDSA` or `RSA`."""
    signature_algorithm: NotRequired[
        Nullable[GetChangeAllowedInputParamChangesResponse200SignatureAlgorithm]
    ]
    r"""Indicates the SHA (Secure Hash Algorithm) function. You can use either `SHA-1` for a 160-bit (20-byte) hash or `SHA-256` for a 256-bit (32-byte) hash."""


class GetChangeAllowedInputParamMultiStackedCertificates(BaseModel):
    certificate: Nullable[str]
    r"""The certificate text."""

    trust_chain: Annotated[Nullable[str], pydantic.Field(alias="trustChain")]
    r"""The trust chain for the certificate."""

    expiry: Optional[str] = None
    r"""The expiration date for the certificate."""

    key_algorithm: Annotated[
        Optional[GetChangeAllowedInputParamKeyAlgorithm],
        pydantic.Field(alias="keyAlgorithm"),
    ] = None
    r"""The key algorithm of the certificate. This is either `ECDSA` or `RSA`."""

    signature_algorithm: Annotated[
        OptionalNullable[
            GetChangeAllowedInputParamChangesResponse200SignatureAlgorithm
        ],
        pydantic.Field(alias="signatureAlgorithm"),
    ] = UNSET
    r"""Indicates the SHA (Secure Hash Algorithm) function. You can use either `SHA-1` for a 160-bit (20-byte) hash or `SHA-256` for a 256-bit (32-byte) hash."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["expiry", "keyAlgorithm", "signatureAlgorithm"]
        nullable_fields = ["certificate", "trustChain", "signatureAlgorithm"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetChangeAllowedInputParamChangesResponseGeography(str, Enum):
    r"""Specifies the type of network where you want to deploy your certificate.  Use `core` to deploy across most of the world except for specially licensed areas.  Use `china+core` to include China, or `russia+core` to include Russia. Any non-`core` deployment needs to be enabled on your contract based on approval from the Chinese or Russian governments."""

    CORE = "core"
    CHINA_PLUS_CORE = "china+core"
    RUSSIA_PLUS_CORE = "russia+core"


class GetChangeAllowedInputParamOcspStapling(str, Enum):
    r"""Indicates the OCSP stapling setting for the deployment. Use `on` to enable OCSP stapling, `off` to disable it, or `not-set` to ignore it."""

    ON = "on"
    OFF = "off"
    NOT_SET = "not-set"


class GetChangeAllowedInputParamSecureNetwork(str, Enum):
    r"""Identifies the type of deployment network. An `enhanced-tls` value means Akamai's more secure network with PCI compliance capability, while `standard-tls` means Akamai's standard secure network."""

    ENHANCED_TLS = "enhanced-tls"
    STANDARD_TLS = "standard-tls"


class GetChangeAllowedInputParamChangesResponseNetworkConfigurationTypedDict(TypedDict):
    r"""Network configuration properties."""

    quic_enabled: bool
    r"""QUIC transport layer network protocol."""
    sni_only: bool
    r"""Server Name Indication (SNI) is an extension of the Transport Layer Security (TLS) networking protocol. It allows a server to present many certificates on the same IP address. All modern web browsers support the SNI extension. If you have the same SAN on two or more certificates with the SNI-only option set, Akamai may serve traffic using any certificate which matches the requested SNI hostname. You should avoid any certificates with overlapping SAN names when using SNI-only."""
    disallowed_tls_versions: NotRequired[List[str]]
    r"""Disallowed TLS protocol."""
    dns_names: NotRequired[List[str]]
    r"""Names served by SNI-only enabled enrollments."""
    geography: NotRequired[GetChangeAllowedInputParamChangesResponseGeography]
    r"""Specifies the type of network where you want to deploy your certificate.  Use `core` to deploy across most of the world except for specially licensed areas.  Use `china+core` to include China, or `russia+core` to include Russia. Any non-`core` deployment needs to be enabled on your contract based on approval from the Chinese or Russian governments."""
    must_have_ciphers: NotRequired[str]
    r"""Ciphers that you definitely want to include for your enrollment while deploying it on the network. For more information on cipher profiles, see [Update SSL/TLS cipher profiles](doc:cipher-profiles)."""
    ocsp_stapling: NotRequired[GetChangeAllowedInputParamOcspStapling]
    r"""Indicates the OCSP stapling setting for the deployment. Use `on` to enable OCSP stapling, `off` to disable it, or `not-set` to ignore it."""
    preferred_ciphers: NotRequired[str]
    r"""Ciphers that you preferably want to include for your enrollment while deploying it on the network. For more information on cipher profiles, see [Update SSL/TLS cipher profiles](doc:cipher-profiles)."""
    secure_network: NotRequired[GetChangeAllowedInputParamSecureNetwork]
    r"""Identifies the type of deployment network. An `enhanced-tls` value means Akamai's more secure network with PCI compliance capability, while `standard-tls` means Akamai's standard secure network."""


class GetChangeAllowedInputParamChangesResponseNetworkConfiguration(BaseModel):
    r"""Network configuration properties."""

    quic_enabled: Annotated[bool, pydantic.Field(alias="quicEnabled")]
    r"""QUIC transport layer network protocol."""

    sni_only: Annotated[bool, pydantic.Field(alias="sniOnly")]
    r"""Server Name Indication (SNI) is an extension of the Transport Layer Security (TLS) networking protocol. It allows a server to present many certificates on the same IP address. All modern web browsers support the SNI extension. If you have the same SAN on two or more certificates with the SNI-only option set, Akamai may serve traffic using any certificate which matches the requested SNI hostname. You should avoid any certificates with overlapping SAN names when using SNI-only."""

    disallowed_tls_versions: Annotated[
        Optional[List[str]], pydantic.Field(alias="disallowedTlsVersions")
    ] = None
    r"""Disallowed TLS protocol."""

    dns_names: Annotated[Optional[List[str]], pydantic.Field(alias="dnsNames")] = None
    r"""Names served by SNI-only enabled enrollments."""

    geography: Optional[GetChangeAllowedInputParamChangesResponseGeography] = None
    r"""Specifies the type of network where you want to deploy your certificate.  Use `core` to deploy across most of the world except for specially licensed areas.  Use `china+core` to include China, or `russia+core` to include Russia. Any non-`core` deployment needs to be enabled on your contract based on approval from the Chinese or Russian governments."""

    must_have_ciphers: Annotated[
        Optional[str], pydantic.Field(alias="mustHaveCiphers")
    ] = None
    r"""Ciphers that you definitely want to include for your enrollment while deploying it on the network. For more information on cipher profiles, see [Update SSL/TLS cipher profiles](doc:cipher-profiles)."""

    ocsp_stapling: Annotated[
        Optional[GetChangeAllowedInputParamOcspStapling],
        pydantic.Field(alias="ocspStapling"),
    ] = None
    r"""Indicates the OCSP stapling setting for the deployment. Use `on` to enable OCSP stapling, `off` to disable it, or `not-set` to ignore it."""

    preferred_ciphers: Annotated[
        Optional[str], pydantic.Field(alias="preferredCiphers")
    ] = None
    r"""Ciphers that you preferably want to include for your enrollment while deploying it on the network. For more information on cipher profiles, see [Update SSL/TLS cipher profiles](doc:cipher-profiles)."""

    secure_network: Annotated[
        Optional[GetChangeAllowedInputParamSecureNetwork],
        pydantic.Field(alias="secureNetwork"),
    ] = None
    r"""Identifies the type of deployment network. An `enhanced-tls` value means Akamai's more secure network with PCI compliance capability, while `standard-tls` means Akamai's standard secure network."""


class GetChangeAllowedInputParamChangesKeyAlgorithm(str, Enum):
    r"""The key algorithm for the multi-stacked certificate. This is either `ECDSA` or `RSA`."""

    ECDSA = "ECDSA"
    RSA = "RSA"


class GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsDeploymentV7PlusJSONSignatureAlgorithm(
    str, Enum
):
    r"""Identifies the SHA (Secure Hash Algorithm) function. The NSA (National Security Agency) designed this function to produce a hash of certificate contents, which is used in a digital signature. This is either `SHA-1` for a 160-bit (20-byte) hash or `SHA-256` for a 256-bit (32-byte) hash. To ensure a secure hash function, use `SHA-256`."""

    SHA_1 = "SHA-1"
    SHA_256 = "SHA-256"


class GetChangeAllowedInputParamPrimaryCertificateTypedDict(TypedDict):
    r"""Primary certificate of the enrollment."""

    certificate: Nullable[str]
    r"""The certificate text."""
    trust_chain: Nullable[str]
    r"""The trust chain for the certificate."""
    expiry: NotRequired[str]
    r"""The expiration date for the certificate."""
    key_algorithm: NotRequired[GetChangeAllowedInputParamChangesKeyAlgorithm]
    r"""The key algorithm for the multi-stacked certificate. This is either `ECDSA` or `RSA`."""
    signature_algorithm: NotRequired[
        Nullable[
            GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsDeploymentV7PlusJSONSignatureAlgorithm
        ]
    ]
    r"""Identifies the SHA (Secure Hash Algorithm) function. The NSA (National Security Agency) designed this function to produce a hash of certificate contents, which is used in a digital signature. This is either `SHA-1` for a 160-bit (20-byte) hash or `SHA-256` for a 256-bit (32-byte) hash. To ensure a secure hash function, use `SHA-256`."""


class GetChangeAllowedInputParamPrimaryCertificate(BaseModel):
    r"""Primary certificate of the enrollment."""

    certificate: Nullable[str]
    r"""The certificate text."""

    trust_chain: Annotated[Nullable[str], pydantic.Field(alias="trustChain")]
    r"""The trust chain for the certificate."""

    expiry: Optional[str] = None
    r"""The expiration date for the certificate."""

    key_algorithm: Annotated[
        Optional[GetChangeAllowedInputParamChangesKeyAlgorithm],
        pydantic.Field(alias="keyAlgorithm"),
    ] = None
    r"""The key algorithm for the multi-stacked certificate. This is either `ECDSA` or `RSA`."""

    signature_algorithm: Annotated[
        OptionalNullable[
            GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsDeploymentV7PlusJSONSignatureAlgorithm
        ],
        pydantic.Field(alias="signatureAlgorithm"),
    ] = UNSET
    r"""Identifies the SHA (Secure Hash Algorithm) function. The NSA (National Security Agency) designed this function to produce a hash of certificate contents, which is used in a digital signature. This is either `SHA-1` for a 160-bit (20-byte) hash or `SHA-256` for a 256-bit (32-byte) hash. To ensure a secure hash function, use `SHA-256`."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["expiry", "keyAlgorithm", "signatureAlgorithm"]
        nullable_fields = ["certificate", "trustChain", "signatureAlgorithm"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsDeploymentV7PlusJSONResponseBodyTypedDict(
    TypedDict
):
    r"""Deploys your certificate to a network."""

    multi_stacked_certificates: List[
        GetChangeAllowedInputParamMultiStackedCertificatesTypedDict
    ]
    r"""Dual-stacked certificates today include an ECDSA certificate in addition to an RSA certificate. Deployment may include many dual-stacked certificates."""
    network_configuration: (
        GetChangeAllowedInputParamChangesResponseNetworkConfigurationTypedDict
    )
    r"""Network configuration properties."""
    primary_certificate: Nullable[GetChangeAllowedInputParamPrimaryCertificateTypedDict]
    r"""Primary certificate of the enrollment."""
    ocsp_stapled: NotRequired[bool]
    r"""OCSP Stapling improves performance by including a valid OCSP response in every TLS handshake. You should enable this feature."""
    ocsp_uris: NotRequired[Nullable[List[str]]]
    r"""URI used for OCSP stapling validation."""


class GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsDeploymentV7PlusJSONResponseBody(
    BaseModel
):
    r"""Deploys your certificate to a network."""

    multi_stacked_certificates: Annotated[
        List[GetChangeAllowedInputParamMultiStackedCertificates],
        pydantic.Field(alias="multiStackedCertificates"),
    ]
    r"""Dual-stacked certificates today include an ECDSA certificate in addition to an RSA certificate. Deployment may include many dual-stacked certificates."""

    network_configuration: Annotated[
        GetChangeAllowedInputParamChangesResponseNetworkConfiguration,
        pydantic.Field(alias="networkConfiguration"),
    ]
    r"""Network configuration properties."""

    primary_certificate: Annotated[
        Nullable[GetChangeAllowedInputParamPrimaryCertificate],
        pydantic.Field(alias="primaryCertificate"),
    ]
    r"""Primary certificate of the enrollment."""

    ocsp_stapled: Annotated[Optional[bool], pydantic.Field(alias="ocspStapled")] = None
    r"""OCSP Stapling improves performance by including a valid OCSP response in every TLS handshake. You should enable this feature."""

    ocsp_uris: Annotated[
        OptionalNullable[List[str]], pydantic.Field(alias="ocspUris")
    ] = UNSET
    r"""URI used for OCSP stapling validation."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["ocspStapled", "ocspUris"]
        nullable_fields = ["primaryCertificate", "ocspUris"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetChangeAllowedInputParamChangesSignatureAlgorithm(str, Enum):
    r"""Identifies the SHA (Secure Hash Algorithm) function. The NSA (National Security Agency) designed this function to produce a hash of certificate contents, which is used in a digital signature. This is either `SHA-1` for a 160-bit (20-byte) hash or `SHA-256` for a 256-bit (32-byte) hash. To ensure a secure hash function, use `SHA-256`."""

    SHA_1 = "SHA-1"
    SHA_256 = "SHA-256"


class MultiStackedCertificatesTypedDict(TypedDict):
    certificate: Nullable[str]
    r"""The certificate text."""
    trust_chain: Nullable[str]
    r"""The trust chain for the certificate."""
    expiry: NotRequired[str]
    r"""The expiration date for the certificate."""
    signature_algorithm: NotRequired[
        Nullable[GetChangeAllowedInputParamChangesSignatureAlgorithm]
    ]
    r"""Identifies the SHA (Secure Hash Algorithm) function. The NSA (National Security Agency) designed this function to produce a hash of certificate contents, which is used in a digital signature. This is either `SHA-1` for a 160-bit (20-byte) hash or `SHA-256` for a 256-bit (32-byte) hash. To ensure a secure hash function, use `SHA-256`."""


class MultiStackedCertificates(BaseModel):
    certificate: Nullable[str]
    r"""The certificate text."""

    trust_chain: Annotated[Nullable[str], pydantic.Field(alias="trustChain")]
    r"""The trust chain for the certificate."""

    expiry: Optional[str] = None
    r"""The expiration date for the certificate."""

    signature_algorithm: Annotated[
        OptionalNullable[GetChangeAllowedInputParamChangesSignatureAlgorithm],
        pydantic.Field(alias="signatureAlgorithm"),
    ] = UNSET
    r"""Identifies the SHA (Secure Hash Algorithm) function. The NSA (National Security Agency) designed this function to produce a hash of certificate contents, which is used in a digital signature. This is either `SHA-1` for a 160-bit (20-byte) hash or `SHA-256` for a 256-bit (32-byte) hash. To ensure a secure hash function, use `SHA-256`."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["expiry", "signatureAlgorithm"]
        nullable_fields = ["certificate", "trustChain", "signatureAlgorithm"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetChangeAllowedInputParamChangesGeography(str, Enum):
    r"""Specifies the type of network where you want to deploy your certificate.  Use `core` to deploy across most of the world except for specially licensed areas.  Use `china+core` to include China, or `russia+core` to include Russia. Any non-`core` deployment needs to be enabled on your contract based on approval from the Chinese or Russian governments."""

    CORE = "core"
    CHINA_PLUS_CORE = "china+core"
    RUSSIA_PLUS_CORE = "russia+core"


class GetChangeAllowedInputParamChangesNetworkConfigurationTypedDict(TypedDict):
    r"""Network configuration properties."""

    quic_enabled: bool
    r"""QUIC transport layer network protocol."""
    sni_only: bool
    r"""Server Name Indication (SNI) is an extension of the Transport Layer Security (TLS) networking protocol. It allows a server to present many certificates on the same IP address. All modern web browsers support the SNI extension. If you have the same SAN on two or more certificates with the SNI-only option set, Akamai may serve traffic using any certificate that matches the requested SNI hostname. You should avoid any certificates with overlapping SAN names when using SNI-only."""
    disallowed_tls_versions: NotRequired[List[str]]
    r"""Disallowed TLS protocol."""
    dns_names: NotRequired[List[str]]
    r"""Names served by SNI-only enabled enrollments."""
    geography: NotRequired[GetChangeAllowedInputParamChangesGeography]
    r"""Specifies the type of network where you want to deploy your certificate.  Use `core` to deploy across most of the world except for specially licensed areas.  Use `china+core` to include China, or `russia+core` to include Russia. Any non-`core` deployment needs to be enabled on your contract based on approval from the Chinese or Russian governments."""
    must_have_ciphers: NotRequired[str]
    r"""Ciphers that you definitely want to include for your enrollment while deploying it on the network. For more information on cipher profiles, see [Update SSL/TLS cipher profiles](doc:cipher-profiles)."""
    ocsp_stapling: NotRequired[str]
    r"""OCSP stapling setting for the deployment."""
    preferred_ciphers: NotRequired[str]
    r"""Ciphers that you preferably want to include for your enrollment while deploying it on the network. For more information on cipher profiles, see [Update SSL/TLS cipher profiles](doc:cipher-profiles)."""
    secure_network: NotRequired[str]
    r"""The type of deployment network. A value of `standard-tls` means Akamai's standard secure network, while `enhanced-tls` means Akamai's more secure network with PCI compliance capability."""


class GetChangeAllowedInputParamChangesNetworkConfiguration(BaseModel):
    r"""Network configuration properties."""

    quic_enabled: Annotated[bool, pydantic.Field(alias="quicEnabled")]
    r"""QUIC transport layer network protocol."""

    sni_only: Annotated[bool, pydantic.Field(alias="sniOnly")]
    r"""Server Name Indication (SNI) is an extension of the Transport Layer Security (TLS) networking protocol. It allows a server to present many certificates on the same IP address. All modern web browsers support the SNI extension. If you have the same SAN on two or more certificates with the SNI-only option set, Akamai may serve traffic using any certificate that matches the requested SNI hostname. You should avoid any certificates with overlapping SAN names when using SNI-only."""

    disallowed_tls_versions: Annotated[
        Optional[List[str]], pydantic.Field(alias="disallowedTlsVersions")
    ] = None
    r"""Disallowed TLS protocol."""

    dns_names: Annotated[Optional[List[str]], pydantic.Field(alias="dnsNames")] = None
    r"""Names served by SNI-only enabled enrollments."""

    geography: Optional[GetChangeAllowedInputParamChangesGeography] = None
    r"""Specifies the type of network where you want to deploy your certificate.  Use `core` to deploy across most of the world except for specially licensed areas.  Use `china+core` to include China, or `russia+core` to include Russia. Any non-`core` deployment needs to be enabled on your contract based on approval from the Chinese or Russian governments."""

    must_have_ciphers: Annotated[
        Optional[str], pydantic.Field(alias="mustHaveCiphers")
    ] = None
    r"""Ciphers that you definitely want to include for your enrollment while deploying it on the network. For more information on cipher profiles, see [Update SSL/TLS cipher profiles](doc:cipher-profiles)."""

    ocsp_stapling: Annotated[Optional[str], pydantic.Field(alias="ocspStapling")] = None
    r"""OCSP stapling setting for the deployment."""

    preferred_ciphers: Annotated[
        Optional[str], pydantic.Field(alias="preferredCiphers")
    ] = None
    r"""Ciphers that you preferably want to include for your enrollment while deploying it on the network. For more information on cipher profiles, see [Update SSL/TLS cipher profiles](doc:cipher-profiles)."""

    secure_network: Annotated[Optional[str], pydantic.Field(alias="secureNetwork")] = (
        None
    )
    r"""The type of deployment network. A value of `standard-tls` means Akamai's standard secure network, while `enhanced-tls` means Akamai's more secure network with PCI compliance capability."""


class GetChangeAllowedInputParamChangesResponseSignatureAlgorithm(str, Enum):
    r"""Identifies the SHA (Secure Hash Algorithm) function. The NSA (National Security Agency) designed this function to produce a hash of certificate contents, for use in a digital signature. This is either `SHA-1` for a 160-bit (20-byte) hash or `SHA-256` for a 256-bit (32-byte) hash. To ensure a secure hash function, use `SHA-256`."""

    SHA_1 = "SHA-1"
    SHA_256 = "SHA-256"


class PrimaryCertificateTypedDict(TypedDict):
    r"""Primary certificate of the enrollment."""

    certificate: Nullable[str]
    r"""The certificate text."""
    trust_chain: Nullable[str]
    r"""The trust chain for the certificate."""
    expiry: NotRequired[str]
    r"""The expiration date for the certificate."""
    signature_algorithm: NotRequired[
        Nullable[GetChangeAllowedInputParamChangesResponseSignatureAlgorithm]
    ]
    r"""Identifies the SHA (Secure Hash Algorithm) function. The NSA (National Security Agency) designed this function to produce a hash of certificate contents, for use in a digital signature. This is either `SHA-1` for a 160-bit (20-byte) hash or `SHA-256` for a 256-bit (32-byte) hash. To ensure a secure hash function, use `SHA-256`."""


class PrimaryCertificate(BaseModel):
    r"""Primary certificate of the enrollment."""

    certificate: Nullable[str]
    r"""The certificate text."""

    trust_chain: Annotated[Nullable[str], pydantic.Field(alias="trustChain")]
    r"""The trust chain for the certificate."""

    expiry: Optional[str] = None
    r"""The expiration date for the certificate."""

    signature_algorithm: Annotated[
        OptionalNullable[GetChangeAllowedInputParamChangesResponseSignatureAlgorithm],
        pydantic.Field(alias="signatureAlgorithm"),
    ] = UNSET
    r"""Identifies the SHA (Secure Hash Algorithm) function. The NSA (National Security Agency) designed this function to produce a hash of certificate contents, for use in a digital signature. This is either `SHA-1` for a 160-bit (20-byte) hash or `SHA-256` for a 256-bit (32-byte) hash. To ensure a secure hash function, use `SHA-256`."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["expiry", "signatureAlgorithm"]
        nullable_fields = ["certificate", "trustChain", "signatureAlgorithm"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsDeploymentV6PlusJSONResponseBodyTypedDict(
    TypedDict
):
    r"""Deploys your certificate to a network."""

    multi_stacked_certificates: List[MultiStackedCertificatesTypedDict]
    r"""Dual-stacked certificates today include an ECDSA certificate in addition to an RSA certificate. Deployment may include many dual-stacked certificates."""
    network_configuration: (
        GetChangeAllowedInputParamChangesNetworkConfigurationTypedDict
    )
    r"""Network configuration properties."""
    primary_certificate: Nullable[PrimaryCertificateTypedDict]
    r"""Primary certificate of the enrollment."""
    ocsp_stapled: NotRequired[bool]
    r"""OCSP Stapling improves performance by including a valid OCSP response in every TLS handshake. You should enable this feature."""
    ocsp_uris: NotRequired[Nullable[List[str]]]
    r"""URI used for OCSP stapling validation."""


class GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsDeploymentV6PlusJSONResponseBody(
    BaseModel
):
    r"""Deploys your certificate to a network."""

    multi_stacked_certificates: Annotated[
        List[MultiStackedCertificates], pydantic.Field(alias="multiStackedCertificates")
    ]
    r"""Dual-stacked certificates today include an ECDSA certificate in addition to an RSA certificate. Deployment may include many dual-stacked certificates."""

    network_configuration: Annotated[
        GetChangeAllowedInputParamChangesNetworkConfiguration,
        pydantic.Field(alias="networkConfiguration"),
    ]
    r"""Network configuration properties."""

    primary_certificate: Annotated[
        Nullable[PrimaryCertificate], pydantic.Field(alias="primaryCertificate")
    ]
    r"""Primary certificate of the enrollment."""

    ocsp_stapled: Annotated[Optional[bool], pydantic.Field(alias="ocspStapled")] = None
    r"""OCSP Stapling improves performance by including a valid OCSP response in every TLS handshake. You should enable this feature."""

    ocsp_uris: Annotated[
        OptionalNullable[List[str]], pydantic.Field(alias="ocspUris")
    ] = UNSET
    r"""URI used for OCSP stapling validation."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["ocspStapled", "ocspUris"]
        nullable_fields = ["primaryCertificate", "ocspUris"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetChangeAllowedInputParamGeography(str, Enum):
    r"""Specifies the type of network where you want to deploy your certificate. Use `core` to deploy across most of the world except for specially licensed areas.  Use `china+core` to include China, or `russia+core` to include Russia. Any non-`core` deployment needs to be enabled on your contract based on approval from the Chinese or Russian governments."""

    CORE = "core"
    CHINA_PLUS_CORE = "china+core"
    RUSSIA_PLUS_CORE = "russia+core"


class SniTypedDict(TypedDict):
    r"""SNI settings for your enrollment. When set to `null`, the enrollment becomes non-SNI. When it is non-null, enrollment is SNI-only. This setting cannot be changed once an enrollment is created."""

    clone_dns_names: bool
    r"""Enable if you want CPS to direct traffic using all the SANs listed in the SANs parameter when you created your enrollment."""
    dns_names: NotRequired[List[str]]
    r"""Names served by SNI-only enabled enrollments."""


class Sni(BaseModel):
    r"""SNI settings for your enrollment. When set to `null`, the enrollment becomes non-SNI. When it is non-null, enrollment is SNI-only. This setting cannot be changed once an enrollment is created."""

    clone_dns_names: Annotated[bool, pydantic.Field(alias="cloneDnsNames")]
    r"""Enable if you want CPS to direct traffic using all the SANs listed in the SANs parameter when you created your enrollment."""

    dns_names: Annotated[Optional[List[str]], pydantic.Field(alias="dnsNames")] = None
    r"""Names served by SNI-only enabled enrollments."""


class GetChangeAllowedInputParamNetworkConfigurationTypedDict(TypedDict):
    r"""Information about how you want to deploy your certificate."""

    disallowed_tls_versions: List[str]
    r"""Disallowed TLS versions."""
    geography: GetChangeAllowedInputParamGeography
    r"""Specifies the type of network where you want to deploy your certificate. Use `core` to deploy across most of the world except for specially licensed areas.  Use `china+core` to include China, or `russia+core` to include Russia. Any non-`core` deployment needs to be enabled on your contract based on approval from the Chinese or Russian governments."""
    must_have_ciphers: str
    r"""Ciphers that you definitely want to include for your enrollment while deploying it on the network. Defaults to `ak-akamai-default` when it is not set."""
    preferred_ciphers: str
    r"""Ciphers that you preferably want to include for your enrollment while deploying it on the network. Defaults to `ak-akamai-default` when it is not set."""
    secure_network: str
    r"""The type of deployment network you want to use. Specify Standard TLS as the enum `standard-tls` to deploy your certificate to Akamai's standard secure network. It is not PCI compliant. Specify Enhanced TLS as the enum `enhanced-tls` to deploy your certificate to Akamai's more secure network with PCI compliance capability."""
    sni: Nullable[SniTypedDict]
    r"""SNI settings for your enrollment. When set to `null`, the enrollment becomes non-SNI. When it is non-null, enrollment is SNI-only. This setting cannot be changed once an enrollment is created."""


class GetChangeAllowedInputParamNetworkConfiguration(BaseModel):
    r"""Information about how you want to deploy your certificate."""

    disallowed_tls_versions: Annotated[
        List[str], pydantic.Field(alias="disallowedTlsVersions")
    ]
    r"""Disallowed TLS versions."""

    geography: GetChangeAllowedInputParamGeography
    r"""Specifies the type of network where you want to deploy your certificate. Use `core` to deploy across most of the world except for specially licensed areas.  Use `china+core` to include China, or `russia+core` to include Russia. Any non-`core` deployment needs to be enabled on your contract based on approval from the Chinese or Russian governments."""

    must_have_ciphers: Annotated[str, pydantic.Field(alias="mustHaveCiphers")]
    r"""Ciphers that you definitely want to include for your enrollment while deploying it on the network. Defaults to `ak-akamai-default` when it is not set."""

    preferred_ciphers: Annotated[str, pydantic.Field(alias="preferredCiphers")]
    r"""Ciphers that you preferably want to include for your enrollment while deploying it on the network. Defaults to `ak-akamai-default` when it is not set."""

    secure_network: Annotated[str, pydantic.Field(alias="secureNetwork")]
    r"""The type of deployment network you want to use. Specify Standard TLS as the enum `standard-tls` to deploy your certificate to Akamai's standard secure network. It is not PCI compliant. Specify Enhanced TLS as the enum `enhanced-tls` to deploy your certificate to Akamai's more secure network with PCI compliance capability."""

    sni: Nullable[Sni]
    r"""SNI settings for your enrollment. When set to `null`, the enrollment becomes non-SNI. When it is non-null, enrollment is SNI-only. This setting cannot be changed once an enrollment is created."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["sni"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetChangeAllowedInputParamSignatureAlgorithm(str, Enum):
    r"""Identifies the SHA (Secure Hash Algorithm) function. The NSA (National Security Agency) designed this function to produce a hash of certificate contents, which is used in a digital signature. This is either `SHA-1` for a 160-bit (20-byte) hash or `SHA-256` for a 256-bit (32-byte) hash. To ensure a secure hash function, use `SHA-256`."""

    SHA_1 = "SHA-1"
    SHA_256 = "SHA-256"


class GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsDeploymentV3PlusJSONResponseBodyTypedDict(
    TypedDict
):
    r"""Deploys your certificate to a network."""

    certificate: Nullable[str]
    r"""The certificate text."""
    network_configuration: GetChangeAllowedInputParamNetworkConfigurationTypedDict
    r"""Information about how you want to deploy your certificate."""
    trust_chain: Nullable[str]
    r"""The trust chain text. You may have any number of trust chains."""
    signature_algorithm: NotRequired[
        Nullable[GetChangeAllowedInputParamSignatureAlgorithm]
    ]
    r"""Identifies the SHA (Secure Hash Algorithm) function. The NSA (National Security Agency) designed this function to produce a hash of certificate contents, which is used in a digital signature. This is either `SHA-1` for a 160-bit (20-byte) hash or `SHA-256` for a 256-bit (32-byte) hash. To ensure a secure hash function, use `SHA-256`."""


class GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsDeploymentV3PlusJSONResponseBody(
    BaseModel
):
    r"""Deploys your certificate to a network."""

    certificate: Nullable[str]
    r"""The certificate text."""

    network_configuration: Annotated[
        GetChangeAllowedInputParamNetworkConfiguration,
        pydantic.Field(alias="networkConfiguration"),
    ]
    r"""Information about how you want to deploy your certificate."""

    trust_chain: Annotated[Nullable[str], pydantic.Field(alias="trustChain")]
    r"""The trust chain text. You may have any number of trust chains."""

    signature_algorithm: Annotated[
        OptionalNullable[GetChangeAllowedInputParamSignatureAlgorithm],
        pydantic.Field(alias="signatureAlgorithm"),
    ] = UNSET
    r"""Identifies the SHA (Secure Hash Algorithm) function. The NSA (National Security Agency) designed this function to produce a hash of certificate contents, which is used in a digital signature. This is either `SHA-1` for a 160-bit (20-byte) hash or `SHA-256` for a 256-bit (32-byte) hash. To ensure a secure hash function, use `SHA-256`."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["signatureAlgorithm"]
        nullable_fields = ["certificate", "trustChain", "signatureAlgorithm"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsCsrV2PlusJSONKeyAlgorithm(
    str, Enum
):
    r"""Key algorithm of the certificate, either `ECDSA` or `RSA`."""

    ECDSA = "ECDSA"
    RSA = "RSA"


class CsrsTypedDict(TypedDict):
    csr: str
    r"""String with PEM formatted CSR."""
    key_algorithm: NotRequired[
        GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsCsrV2PlusJSONKeyAlgorithm
    ]
    r"""Key algorithm of the certificate, either `ECDSA` or `RSA`."""


class Csrs(BaseModel):
    csr: str
    r"""String with PEM formatted CSR."""

    key_algorithm: Annotated[
        Optional[
            GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsCsrV2PlusJSONKeyAlgorithm
        ],
        pydantic.Field(alias="keyAlgorithm"),
    ] = None
    r"""Key algorithm of the certificate, either `ECDSA` or `RSA`."""


class GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsCsrV2PlusJSONResponseBodyTypedDict(
    TypedDict
):
    r"""Certificate Signing Request (CSR)."""

    csrs: List[CsrsTypedDict]
    r"""Certificate Signing Request (CSR) objects."""


class GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsCsrV2PlusJSONResponseBody(
    BaseModel
):
    r"""Certificate Signing Request (CSR)."""

    csrs: List[Csrs]
    r"""Certificate Signing Request (CSR) objects."""


class GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsCsrV1PlusJSONResponseBodyTypedDict(
    TypedDict
):
    r"""Certificate Signing Request (CSR)."""

    csr: Nullable[str]
    r"""String with PEM formatted CSR."""


class GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsCsrV1PlusJSONResponseBody(
    BaseModel
):
    r"""Certificate Signing Request (CSR)."""

    csr: Nullable[str]
    r"""String with PEM formatted CSR."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["csr"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetChangeAllowedInputParamChangesResponse200CertificateType(str, Enum):
    r"""Determines the certificate's validation type and number of domains the certificate supports. This is either `san`, `single`, `wildcard`, `wildcard-san`, or `third-party`."""

    SAN = "san"
    SINGLE = "single"
    WILDCARD = "wildcard"
    WILDCARD_SAN = "wildcard-san"
    THIRD_PARTY = "third-party"


class GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsChangeManagementInfoV6PlusJSONKeyAlgorithm(
    str, Enum
):
    r"""Displays the key algorithm of the certificate. This is either `ECDSA` or `RSA`."""

    ECDSA = "ECDSA"
    RSA = "RSA"


class GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsChangeManagementInfoV6PlusJSONSignatureAlgorithm(
    str, Enum
):
    r"""Displays the signature algorithm. Either `SHA-1` or `SHA-256`."""

    SHA_1 = "SHA-1"
    SHA_256 = "SHA-256"


class GetChangeAllowedInputParamPendingCertificatesTypedDict(TypedDict):
    certificate_type: GetChangeAllowedInputParamChangesResponse200CertificateType
    r"""Determines the certificate's validation type and number of domains the certificate supports. This is either `san`, `single`, `wildcard`, `wildcard-san`, or `third-party`."""
    full_certificate: str
    r"""Displays the contents of the certificate."""
    signature_algorithm: Nullable[
        GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsChangeManagementInfoV6PlusJSONSignatureAlgorithm
    ]
    r"""Displays the signature algorithm. Either `SHA-1` or `SHA-256`."""
    key_algorithm: NotRequired[
        GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsChangeManagementInfoV6PlusJSONKeyAlgorithm
    ]
    r"""Displays the key algorithm of the certificate. This is either `ECDSA` or `RSA`."""
    ocsp_stapled: NotRequired[bool]
    r"""OCSP Stapling improves performance by including a valid OCSP response in every TLS handshake. You should enable this feature."""
    ocsp_uris: NotRequired[Nullable[List[str]]]
    r"""URI used for OCSP stapling validation."""


class GetChangeAllowedInputParamPendingCertificates(BaseModel):
    certificate_type: Annotated[
        GetChangeAllowedInputParamChangesResponse200CertificateType,
        pydantic.Field(alias="certificateType"),
    ]
    r"""Determines the certificate's validation type and number of domains the certificate supports. This is either `san`, `single`, `wildcard`, `wildcard-san`, or `third-party`."""

    full_certificate: Annotated[str, pydantic.Field(alias="fullCertificate")]
    r"""Displays the contents of the certificate."""

    signature_algorithm: Annotated[
        Nullable[
            GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsChangeManagementInfoV6PlusJSONSignatureAlgorithm
        ],
        pydantic.Field(alias="signatureAlgorithm"),
    ]
    r"""Displays the signature algorithm. Either `SHA-1` or `SHA-256`."""

    key_algorithm: Annotated[
        Optional[
            GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsChangeManagementInfoV6PlusJSONKeyAlgorithm
        ],
        pydantic.Field(alias="keyAlgorithm"),
    ] = None
    r"""Displays the key algorithm of the certificate. This is either `ECDSA` or `RSA`."""

    ocsp_stapled: Annotated[Optional[bool], pydantic.Field(alias="ocspStapled")] = None
    r"""OCSP Stapling improves performance by including a valid OCSP response in every TLS handshake. You should enable this feature."""

    ocsp_uris: Annotated[
        OptionalNullable[List[str]], pydantic.Field(alias="ocspUris")
    ] = UNSET
    r"""URI used for OCSP stapling validation."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["keyAlgorithm", "ocspStapled", "ocspUris"]
        nullable_fields = ["signatureAlgorithm", "ocspUris"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetChangeAllowedInputParamChangesResponseDNSNameSettingsTypedDict(TypedDict):
    r"""DNS name settings."""

    clone_dns_names: bool
    r"""When `true`, all certificate SANs are included in `dnsNames`."""
    dns_names: NotRequired[Nullable[List[str]]]
    r"""Names served by SNI-only enabled enrollments."""


class GetChangeAllowedInputParamChangesResponseDNSNameSettings(BaseModel):
    r"""DNS name settings."""

    clone_dns_names: Annotated[bool, pydantic.Field(alias="cloneDnsNames")]
    r"""When `true`, all certificate SANs are included in `dnsNames`."""

    dns_names: Annotated[
        OptionalNullable[List[str]], pydantic.Field(alias="dnsNames")
    ] = UNSET
    r"""Names served by SNI-only enabled enrollments."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["dnsNames"]
        nullable_fields = ["dnsNames"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetChangeAllowedInputParamChangesResponse200OcspStapling(str, Enum):
    r"""Indicates the OCSP stapling setting for the deployment. Use `on` to enable OCSP stapling, `off` to disable it, or `not-set` to ignore it."""

    ON = "on"
    OFF = "off"
    NOT_SET = "not-set"


class GetChangeAllowedInputParamChangesResponse200PendingNetworkConfigurationTypedDict(
    TypedDict
):
    r"""The snapshot of the pending network configuration for the enrollment when this change takes effect."""

    must_have_ciphers: str
    r"""Ciphers included for your enrollment while deploying it on the network."""
    preferred_ciphers: str
    r"""Ciphers included for your enrollment while deploying it on the network."""
    quic_enabled: bool
    r"""QUIC transport layer network protocol."""
    sni_only: bool
    r"""Server Name Indication (SNI) setting for this Enrollment."""
    disallowed_tls_versions: NotRequired[List[str]]
    r"""Disallowed TLS protocols."""
    dns_name_settings: NotRequired[
        Nullable[GetChangeAllowedInputParamChangesResponseDNSNameSettingsTypedDict]
    ]
    r"""DNS name settings."""
    fips_mode: NotRequired[Nullable[bool]]
    r"""Enables Federal Information Processing Standards (FIPS) for the enrollment."""
    network_type: NotRequired[Nullable[str]]
    r"""Enrollment network type."""
    ocsp_stapling: NotRequired[GetChangeAllowedInputParamChangesResponse200OcspStapling]
    r"""Indicates the OCSP stapling setting for the deployment. Use `on` to enable OCSP stapling, `off` to disable it, or `not-set` to ignore it."""


class GetChangeAllowedInputParamChangesResponse200PendingNetworkConfiguration(
    BaseModel
):
    r"""The snapshot of the pending network configuration for the enrollment when this change takes effect."""

    must_have_ciphers: Annotated[str, pydantic.Field(alias="mustHaveCiphers")]
    r"""Ciphers included for your enrollment while deploying it on the network."""

    preferred_ciphers: Annotated[str, pydantic.Field(alias="preferredCiphers")]
    r"""Ciphers included for your enrollment while deploying it on the network."""

    quic_enabled: Annotated[bool, pydantic.Field(alias="quicEnabled")]
    r"""QUIC transport layer network protocol."""

    sni_only: Annotated[bool, pydantic.Field(alias="sniOnly")]
    r"""Server Name Indication (SNI) setting for this Enrollment."""

    disallowed_tls_versions: Annotated[
        Optional[List[str]], pydantic.Field(alias="disallowedTlsVersions")
    ] = None
    r"""Disallowed TLS protocols."""

    dns_name_settings: Annotated[
        OptionalNullable[GetChangeAllowedInputParamChangesResponseDNSNameSettings],
        pydantic.Field(alias="dnsNameSettings"),
    ] = UNSET
    r"""DNS name settings."""

    fips_mode: Annotated[OptionalNullable[bool], pydantic.Field(alias="fipsMode")] = (
        UNSET
    )
    r"""Enables Federal Information Processing Standards (FIPS) for the enrollment."""

    network_type: Annotated[
        OptionalNullable[str], pydantic.Field(alias="networkType")
    ] = UNSET
    r"""Enrollment network type."""

    ocsp_stapling: Annotated[
        Optional[GetChangeAllowedInputParamChangesResponse200OcspStapling],
        pydantic.Field(alias="ocspStapling"),
    ] = None
    r"""Indicates the OCSP stapling setting for the deployment. Use `on` to enable OCSP stapling, `off` to disable it, or `not-set` to ignore it."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "disallowedTlsVersions",
            "dnsNameSettings",
            "fipsMode",
            "networkType",
            "ocspStapling",
        ]
        nullable_fields = ["dnsNameSettings", "fipsMode", "networkType"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetChangeAllowedInputParamChangesResponse200PendingStateTypedDict(TypedDict):
    r"""The snapshot of the pending state for the enrollment when this change takes effect."""

    pending_certificates: List[GetChangeAllowedInputParamPendingCertificatesTypedDict]
    r"""The snapshot of the pending certificate for the enrollment when this change takes effect."""
    pending_network_configuration: (
        GetChangeAllowedInputParamChangesResponse200PendingNetworkConfigurationTypedDict
    )
    r"""The snapshot of the pending network configuration for the enrollment when this change takes effect."""


class GetChangeAllowedInputParamChangesResponse200PendingState(BaseModel):
    r"""The snapshot of the pending state for the enrollment when this change takes effect."""

    pending_certificates: Annotated[
        List[GetChangeAllowedInputParamPendingCertificates],
        pydantic.Field(alias="pendingCertificates"),
    ]
    r"""The snapshot of the pending certificate for the enrollment when this change takes effect."""

    pending_network_configuration: Annotated[
        GetChangeAllowedInputParamChangesResponse200PendingNetworkConfiguration,
        pydantic.Field(alias="pendingNetworkConfiguration"),
    ]
    r"""The snapshot of the pending network configuration for the enrollment when this change takes effect."""


class GetChangeAllowedInputParamChangesResponse200ErrorsTypedDict(TypedDict):
    message: str
    r"""The description of the message."""
    message_code: str
    r"""The unique code of the message."""


class GetChangeAllowedInputParamChangesResponse200Errors(BaseModel):
    message: str
    r"""The description of the message."""

    message_code: Annotated[str, pydantic.Field(alias="messageCode")]
    r"""The unique code of the message."""


class GetChangeAllowedInputParamChangesResponse200WarningsTypedDict(TypedDict):
    message: str
    r"""The description of the message."""
    message_code: str
    r"""The unique code of the message."""


class GetChangeAllowedInputParamChangesResponse200Warnings(BaseModel):
    message: str
    r"""The description of the message."""

    message_code: Annotated[str, pydantic.Field(alias="messageCode")]
    r"""The unique code of the message."""


class GetChangeAllowedInputParamChangesResponse200ValidationResultTypedDict(TypedDict):
    r"""Provides information about the hash's most recent validation check, indicating the change's current job state. This object appears in the response, even when its value is `null`. Before you run the [Update a change](ref:post-change-allowed-input-param) operation, review the change's validation results and resolve any issues."""

    errors: Nullable[List[GetChangeAllowedInputParamChangesResponse200ErrorsTypedDict]]
    r"""Validation errors of the current job state. Errors prevent a change from proceeding until you resolve them. They are optional and only appear if there are any errors."""
    warnings: List[GetChangeAllowedInputParamChangesResponse200WarningsTypedDict]
    r"""Validation warnings of the current job state. Warnings suspend the execution of a change. You can acknowledge or deny warnings. If you acknowledge them, the change proceeds with its operation. They are optional and only appear if there are any warnings."""


class GetChangeAllowedInputParamChangesResponse200ValidationResult(BaseModel):
    r"""Provides information about the hash's most recent validation check, indicating the change's current job state. This object appears in the response, even when its value is `null`. Before you run the [Update a change](ref:post-change-allowed-input-param) operation, review the change's validation results and resolve any issues."""

    errors: Nullable[List[GetChangeAllowedInputParamChangesResponse200Errors]]
    r"""Validation errors of the current job state. Errors prevent a change from proceeding until you resolve them. They are optional and only appear if there are any errors."""

    warnings: List[GetChangeAllowedInputParamChangesResponse200Warnings]
    r"""Validation warnings of the current job state. Warnings suspend the execution of a change. You can acknowledge or deny warnings. If you acknowledge them, the change proceeds with its operation. They are optional and only appear if there are any warnings."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["errors"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsChangeManagementInfoV6PlusJSONResponseBodyTypedDict(
    TypedDict
):
    r"""After you create an enrollment, you can have CPS halt deployment when the certificate becomes available, so that you can test and view the certificate on a staging server prior to deployment in the production network. If you do not want CPS to automatically deploy the certificate to the production network after it receives the signed certificate from the CA, you can turn change management on for the enrollment. This stops CPS from deploying the certificate to the network until you acknowledge that you are ready to deploy the certificate."""

    pending_state: GetChangeAllowedInputParamChangesResponse200PendingStateTypedDict
    r"""The snapshot of the pending state for the enrollment when this change takes effect."""
    validation_result_hash: str
    r"""The hash of `validationResult`."""
    acknowledgement_deadline: NotRequired[Nullable[str]]
    r"""ISO 8601 timestamp for the user's deadline to acknowledge the change management validation result, before CPS attempts to deploy the pending state to the live network. The value is `null` if there's no existing certificate on the network for the current enrollment."""
    validation_result: NotRequired[
        GetChangeAllowedInputParamChangesResponse200ValidationResultTypedDict
    ]
    r"""Provides information about the hash's most recent validation check, indicating the change's current job state. This object appears in the response, even when its value is `null`. Before you run the [Update a change](ref:post-change-allowed-input-param) operation, review the change's validation results and resolve any issues."""


class GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsChangeManagementInfoV6PlusJSONResponseBody(
    BaseModel
):
    r"""After you create an enrollment, you can have CPS halt deployment when the certificate becomes available, so that you can test and view the certificate on a staging server prior to deployment in the production network. If you do not want CPS to automatically deploy the certificate to the production network after it receives the signed certificate from the CA, you can turn change management on for the enrollment. This stops CPS from deploying the certificate to the network until you acknowledge that you are ready to deploy the certificate."""

    pending_state: Annotated[
        GetChangeAllowedInputParamChangesResponse200PendingState,
        pydantic.Field(alias="pendingState"),
    ]
    r"""The snapshot of the pending state for the enrollment when this change takes effect."""

    validation_result_hash: Annotated[str, pydantic.Field(alias="validationResultHash")]
    r"""The hash of `validationResult`."""

    acknowledgement_deadline: Annotated[
        OptionalNullable[str], pydantic.Field(alias="acknowledgementDeadline")
    ] = UNSET
    r"""ISO 8601 timestamp for the user's deadline to acknowledge the change management validation result, before CPS attempts to deploy the pending state to the live network. The value is `null` if there's no existing certificate on the network for the current enrollment."""

    validation_result: Annotated[
        Optional[GetChangeAllowedInputParamChangesResponse200ValidationResult],
        pydantic.Field(alias="validationResult"),
    ] = None
    r"""Provides information about the hash's most recent validation check, indicating the change's current job state. This object appears in the response, even when its value is `null`. Before you run the [Update a change](ref:post-change-allowed-input-param) operation, review the change's validation results and resolve any issues."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["acknowledgementDeadline", "validationResult"]
        nullable_fields = ["acknowledgementDeadline"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetChangeAllowedInputParamChangesResponseCertificateType(str, Enum):
    r"""Determines the certificate's validation type and number of domains the certificate supports. This is either `san`, `single`, `wildcard`, `wildcard-san`, or `third-party`."""

    SAN = "san"
    SINGLE = "single"
    WILDCARD = "wildcard"
    WILDCARD_SAN = "wildcard-san"
    THIRD_PARTY = "third-party"


class GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsChangeManagementInfoV5PlusJSONKeyAlgorithm(
    str, Enum
):
    r"""Displays the key algorithm of the certificate. This is either `ECDSA` or `RSA`."""

    ECDSA = "ECDSA"
    RSA = "RSA"


class GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsChangeManagementInfoV5PlusJSONSignatureAlgorithm(
    str, Enum
):
    r"""Displays the signature algorithm. Either `SHA-1` or `SHA-256`."""

    SHA_1 = "SHA-1"
    SHA_256 = "SHA-256"


class PendingCertificatesTypedDict(TypedDict):
    certificate_type: GetChangeAllowedInputParamChangesResponseCertificateType
    r"""Determines the certificate's validation type and number of domains the certificate supports. This is either `san`, `single`, `wildcard`, `wildcard-san`, or `third-party`."""
    full_certificate: str
    r"""Displays the contents of the certificate."""
    signature_algorithm: Nullable[
        GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsChangeManagementInfoV5PlusJSONSignatureAlgorithm
    ]
    r"""Displays the signature algorithm. Either `SHA-1` or `SHA-256`."""
    key_algorithm: NotRequired[
        GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsChangeManagementInfoV5PlusJSONKeyAlgorithm
    ]
    r"""Displays the key algorithm of the certificate. This is either `ECDSA` or `RSA`."""
    ocsp_stapled: NotRequired[bool]
    r"""OCSP Stapling improves performance by including a valid OCSP response in every TLS handshake. You should enable this feature."""
    ocsp_uris: NotRequired[Nullable[List[str]]]
    r"""URI used for OCSP stapling validation."""


class PendingCertificates(BaseModel):
    certificate_type: Annotated[
        GetChangeAllowedInputParamChangesResponseCertificateType,
        pydantic.Field(alias="certificateType"),
    ]
    r"""Determines the certificate's validation type and number of domains the certificate supports. This is either `san`, `single`, `wildcard`, `wildcard-san`, or `third-party`."""

    full_certificate: Annotated[str, pydantic.Field(alias="fullCertificate")]
    r"""Displays the contents of the certificate."""

    signature_algorithm: Annotated[
        Nullable[
            GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsChangeManagementInfoV5PlusJSONSignatureAlgorithm
        ],
        pydantic.Field(alias="signatureAlgorithm"),
    ]
    r"""Displays the signature algorithm. Either `SHA-1` or `SHA-256`."""

    key_algorithm: Annotated[
        Optional[
            GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsChangeManagementInfoV5PlusJSONKeyAlgorithm
        ],
        pydantic.Field(alias="keyAlgorithm"),
    ] = None
    r"""Displays the key algorithm of the certificate. This is either `ECDSA` or `RSA`."""

    ocsp_stapled: Annotated[Optional[bool], pydantic.Field(alias="ocspStapled")] = None
    r"""OCSP Stapling improves performance by including a valid OCSP response in every TLS handshake. You should enable this feature."""

    ocsp_uris: Annotated[
        OptionalNullable[List[str]], pydantic.Field(alias="ocspUris")
    ] = UNSET
    r"""URI used for OCSP stapling validation."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["keyAlgorithm", "ocspStapled", "ocspUris"]
        nullable_fields = ["signatureAlgorithm", "ocspUris"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetChangeAllowedInputParamChangesDNSNameSettingsTypedDict(TypedDict):
    r"""DNS name settings."""

    clone_dns_names: bool
    r"""When `true`, all certificate SANs are included in `dnsNames`."""
    dns_names: NotRequired[Nullable[List[str]]]
    r"""Names served by SNI-only enabled enrollments."""


class GetChangeAllowedInputParamChangesDNSNameSettings(BaseModel):
    r"""DNS name settings."""

    clone_dns_names: Annotated[bool, pydantic.Field(alias="cloneDnsNames")]
    r"""When `true`, all certificate SANs are included in `dnsNames`."""

    dns_names: Annotated[
        OptionalNullable[List[str]], pydantic.Field(alias="dnsNames")
    ] = UNSET
    r"""Names served by SNI-only enabled enrollments."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["dnsNames"]
        nullable_fields = ["dnsNames"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetChangeAllowedInputParamChangesResponseOcspStapling(str, Enum):
    r"""Indicates the OCSP stapling setting for the deployment. Use `on` to enable OCSP stapling, `off` to disable it, or `not-set` to ignore it."""

    ON = "on"
    OFF = "off"
    NOT_SET = "not-set"


class GetChangeAllowedInputParamChangesResponsePendingNetworkConfigurationTypedDict(
    TypedDict
):
    r"""The snapshot of the pending network configuration for the enrollment when this change takes effect."""

    must_have_ciphers: str
    r"""Ciphers included for your enrollment while deploying it on the network."""
    preferred_ciphers: str
    r"""Ciphers included for your enrollment while deploying it on the network."""
    quic_enabled: bool
    r"""QUIC transport layer network protocol."""
    sni_only: bool
    r"""Server Name Indication (SNI) setting for this Enrollment."""
    disallowed_tls_versions: NotRequired[List[str]]
    r"""Disallowed TLS protocols."""
    dns_name_settings: NotRequired[
        Nullable[GetChangeAllowedInputParamChangesDNSNameSettingsTypedDict]
    ]
    r"""DNS name settings."""
    network_type: NotRequired[Nullable[str]]
    r"""Enrollment network type."""
    ocsp_stapling: NotRequired[GetChangeAllowedInputParamChangesResponseOcspStapling]
    r"""Indicates the OCSP stapling setting for the deployment. Use `on` to enable OCSP stapling, `off` to disable it, or `not-set` to ignore it."""


class GetChangeAllowedInputParamChangesResponsePendingNetworkConfiguration(BaseModel):
    r"""The snapshot of the pending network configuration for the enrollment when this change takes effect."""

    must_have_ciphers: Annotated[str, pydantic.Field(alias="mustHaveCiphers")]
    r"""Ciphers included for your enrollment while deploying it on the network."""

    preferred_ciphers: Annotated[str, pydantic.Field(alias="preferredCiphers")]
    r"""Ciphers included for your enrollment while deploying it on the network."""

    quic_enabled: Annotated[bool, pydantic.Field(alias="quicEnabled")]
    r"""QUIC transport layer network protocol."""

    sni_only: Annotated[bool, pydantic.Field(alias="sniOnly")]
    r"""Server Name Indication (SNI) setting for this Enrollment."""

    disallowed_tls_versions: Annotated[
        Optional[List[str]], pydantic.Field(alias="disallowedTlsVersions")
    ] = None
    r"""Disallowed TLS protocols."""

    dns_name_settings: Annotated[
        OptionalNullable[GetChangeAllowedInputParamChangesDNSNameSettings],
        pydantic.Field(alias="dnsNameSettings"),
    ] = UNSET
    r"""DNS name settings."""

    network_type: Annotated[
        OptionalNullable[str], pydantic.Field(alias="networkType")
    ] = UNSET
    r"""Enrollment network type."""

    ocsp_stapling: Annotated[
        Optional[GetChangeAllowedInputParamChangesResponseOcspStapling],
        pydantic.Field(alias="ocspStapling"),
    ] = None
    r"""Indicates the OCSP stapling setting for the deployment. Use `on` to enable OCSP stapling, `off` to disable it, or `not-set` to ignore it."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "disallowedTlsVersions",
            "dnsNameSettings",
            "networkType",
            "ocspStapling",
        ]
        nullable_fields = ["dnsNameSettings", "networkType"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetChangeAllowedInputParamChangesResponsePendingStateTypedDict(TypedDict):
    r"""The snapshot of the pending state for the enrollment when this change takes effect."""

    pending_certificates: List[PendingCertificatesTypedDict]
    r"""The snapshot of the pending certificate for the enrollment when this change takes effect."""
    pending_network_configuration: (
        GetChangeAllowedInputParamChangesResponsePendingNetworkConfigurationTypedDict
    )
    r"""The snapshot of the pending network configuration for the enrollment when this change takes effect."""


class GetChangeAllowedInputParamChangesResponsePendingState(BaseModel):
    r"""The snapshot of the pending state for the enrollment when this change takes effect."""

    pending_certificates: Annotated[
        List[PendingCertificates], pydantic.Field(alias="pendingCertificates")
    ]
    r"""The snapshot of the pending certificate for the enrollment when this change takes effect."""

    pending_network_configuration: Annotated[
        GetChangeAllowedInputParamChangesResponsePendingNetworkConfiguration,
        pydantic.Field(alias="pendingNetworkConfiguration"),
    ]
    r"""The snapshot of the pending network configuration for the enrollment when this change takes effect."""


class GetChangeAllowedInputParamChangesResponseErrorsTypedDict(TypedDict):
    message: str
    r"""The description of the message."""
    message_code: str
    r"""The unique code of the message."""


class GetChangeAllowedInputParamChangesResponseErrors(BaseModel):
    message: str
    r"""The description of the message."""

    message_code: Annotated[str, pydantic.Field(alias="messageCode")]
    r"""The unique code of the message."""


class GetChangeAllowedInputParamChangesResponseWarningsTypedDict(TypedDict):
    message: str
    r"""The description of the message."""
    message_code: str
    r"""The unique code of the message."""


class GetChangeAllowedInputParamChangesResponseWarnings(BaseModel):
    message: str
    r"""The description of the message."""

    message_code: Annotated[str, pydantic.Field(alias="messageCode")]
    r"""The unique code of the message."""


class GetChangeAllowedInputParamChangesResponseValidationResultTypedDict(TypedDict):
    r"""Provides information about the hash's most recent validation check, indicating the change's current job state. This object appears in the response, even when its value is `null`. Before you run the [Update a change](ref:post-change-allowed-input-param) operation, review the change's validation results and resolve any issues."""

    errors: Nullable[List[GetChangeAllowedInputParamChangesResponseErrorsTypedDict]]
    r"""Validation errors of the current job state. Errors prevent a change from proceeding until you resolve them. They are optional and only appear if there are any errors."""
    warnings: List[GetChangeAllowedInputParamChangesResponseWarningsTypedDict]
    r"""Validation warnings of the current job state. Warnings suspend the execution of a change. You can acknowledge or deny warnings. If you acknowledge them, the change proceeds with its operation. They are optional and only appear if there are any warnings."""


class GetChangeAllowedInputParamChangesResponseValidationResult(BaseModel):
    r"""Provides information about the hash's most recent validation check, indicating the change's current job state. This object appears in the response, even when its value is `null`. Before you run the [Update a change](ref:post-change-allowed-input-param) operation, review the change's validation results and resolve any issues."""

    errors: Nullable[List[GetChangeAllowedInputParamChangesResponseErrors]]
    r"""Validation errors of the current job state. Errors prevent a change from proceeding until you resolve them. They are optional and only appear if there are any errors."""

    warnings: List[GetChangeAllowedInputParamChangesResponseWarnings]
    r"""Validation warnings of the current job state. Warnings suspend the execution of a change. You can acknowledge or deny warnings. If you acknowledge them, the change proceeds with its operation. They are optional and only appear if there are any warnings."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["errors"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetChangeAllowedInputParamChangesResponse200ResponseBodyTypedDict(TypedDict):
    r"""After you create an enrollment, you can have CPS halt deployment when the certificate becomes available, so that you can test and view the certificate on a staging server prior to deployment in the production network. If you do not want CPS to automatically deploy the certificate to the production network after it receives the signed certificate from the CA, you can turn change management on for the enrollment. This stops CPS from deploying the certificate to the network until you acknowledge that you are ready to deploy the certificate."""

    pending_state: GetChangeAllowedInputParamChangesResponsePendingStateTypedDict
    r"""The snapshot of the pending state for the enrollment when this change takes effect."""
    validation_result_hash: str
    r"""The hash of `validationResult`."""
    acknowledgement_deadline: NotRequired[Nullable[str]]
    r"""ISO 8601 timestamp for the user's deadline to acknowledge the change management validation result, before CPS attempts to deploy the pending state to the live network. The value is `null` if there's no existing certificate on the network for the current enrollment."""
    validation_result: NotRequired[
        GetChangeAllowedInputParamChangesResponseValidationResultTypedDict
    ]
    r"""Provides information about the hash's most recent validation check, indicating the change's current job state. This object appears in the response, even when its value is `null`. Before you run the [Update a change](ref:post-change-allowed-input-param) operation, review the change's validation results and resolve any issues."""


class GetChangeAllowedInputParamChangesResponse200ResponseBody(BaseModel):
    r"""After you create an enrollment, you can have CPS halt deployment when the certificate becomes available, so that you can test and view the certificate on a staging server prior to deployment in the production network. If you do not want CPS to automatically deploy the certificate to the production network after it receives the signed certificate from the CA, you can turn change management on for the enrollment. This stops CPS from deploying the certificate to the network until you acknowledge that you are ready to deploy the certificate."""

    pending_state: Annotated[
        GetChangeAllowedInputParamChangesResponsePendingState,
        pydantic.Field(alias="pendingState"),
    ]
    r"""The snapshot of the pending state for the enrollment when this change takes effect."""

    validation_result_hash: Annotated[str, pydantic.Field(alias="validationResultHash")]
    r"""The hash of `validationResult`."""

    acknowledgement_deadline: Annotated[
        OptionalNullable[str], pydantic.Field(alias="acknowledgementDeadline")
    ] = UNSET
    r"""ISO 8601 timestamp for the user's deadline to acknowledge the change management validation result, before CPS attempts to deploy the pending state to the live network. The value is `null` if there's no existing certificate on the network for the current enrollment."""

    validation_result: Annotated[
        Optional[GetChangeAllowedInputParamChangesResponseValidationResult],
        pydantic.Field(alias="validationResult"),
    ] = None
    r"""Provides information about the hash's most recent validation check, indicating the change's current job state. This object appears in the response, even when its value is `null`. Before you run the [Update a change](ref:post-change-allowed-input-param) operation, review the change's validation results and resolve any issues."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["acknowledgementDeadline", "validationResult"]
        nullable_fields = ["acknowledgementDeadline"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetChangeAllowedInputParamChangesCertificateType(str, Enum):
    r"""Either `san`, `single`, `wildcard`, `wildcard-san`, or `third-party`."""

    SAN = "san"
    SINGLE = "single"
    WILDCARD = "wildcard"
    WILDCARD_SAN = "wildcard-san"
    THIRD_PARTY = "third-party"


class GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsChangeManagementInfoV4PlusJSONSignatureAlgorithm(
    str, Enum
):
    r"""Displays the signature algorithm. Either `SHA-1` or `SHA-256`."""

    SHA_1 = "SHA-1"
    SHA_256 = "SHA-256"


class GetChangeAllowedInputParamChangesPendingCertificateTypedDict(TypedDict):
    r"""The snapshot of the pending certificate for the enrollment when this change takes effect."""

    certificate_type: GetChangeAllowedInputParamChangesCertificateType
    r"""Either `san`, `single`, `wildcard`, `wildcard-san`, or `third-party`."""
    full_certificate: str
    r"""Displays the contents of the certificate."""
    signature_algorithm: Nullable[
        GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsChangeManagementInfoV4PlusJSONSignatureAlgorithm
    ]
    r"""Displays the signature algorithm. Either `SHA-1` or `SHA-256`."""
    ocsp_stapled: NotRequired[bool]
    r"""OCSP Stapling improves performance by including a valid OCSP response in every TLS handshake. You should enable this feature."""
    ocsp_uris: NotRequired[Nullable[List[str]]]
    r"""URI used for OCSP stapling validation."""


class GetChangeAllowedInputParamChangesPendingCertificate(BaseModel):
    r"""The snapshot of the pending certificate for the enrollment when this change takes effect."""

    certificate_type: Annotated[
        GetChangeAllowedInputParamChangesCertificateType,
        pydantic.Field(alias="certificateType"),
    ]
    r"""Either `san`, `single`, `wildcard`, `wildcard-san`, or `third-party`."""

    full_certificate: Annotated[str, pydantic.Field(alias="fullCertificate")]
    r"""Displays the contents of the certificate."""

    signature_algorithm: Annotated[
        Nullable[
            GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsChangeManagementInfoV4PlusJSONSignatureAlgorithm
        ],
        pydantic.Field(alias="signatureAlgorithm"),
    ]
    r"""Displays the signature algorithm. Either `SHA-1` or `SHA-256`."""

    ocsp_stapled: Annotated[Optional[bool], pydantic.Field(alias="ocspStapled")] = None
    r"""OCSP Stapling improves performance by including a valid OCSP response in every TLS handshake. You should enable this feature."""

    ocsp_uris: Annotated[
        OptionalNullable[List[str]], pydantic.Field(alias="ocspUris")
    ] = UNSET
    r"""URI used for OCSP stapling validation."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["ocspStapled", "ocspUris"]
        nullable_fields = ["signatureAlgorithm", "ocspUris"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetChangeAllowedInputParamDNSNameSettingsTypedDict(TypedDict):
    r"""DNS name settings."""

    clone_dns_names: bool
    r"""When `true`, all certificate SANs are included in `dnsNames`."""
    dns_names: NotRequired[Nullable[List[str]]]
    r"""Names served by SNI-only enabled enrollments."""


class GetChangeAllowedInputParamDNSNameSettings(BaseModel):
    r"""DNS name settings."""

    clone_dns_names: Annotated[bool, pydantic.Field(alias="cloneDnsNames")]
    r"""When `true`, all certificate SANs are included in `dnsNames`."""

    dns_names: Annotated[
        OptionalNullable[List[str]], pydantic.Field(alias="dnsNames")
    ] = UNSET
    r"""Names served by SNI-only enabled enrollments."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["dnsNames"]
        nullable_fields = ["dnsNames"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetChangeAllowedInputParamChangesPendingNetworkConfigurationTypedDict(TypedDict):
    r"""The snapshot of the pending network configuration for the enrollment when this change takes effect."""

    must_have_ciphers: str
    r"""Ciphers included for your enrollment while deploying it on the network."""
    preferred_ciphers: str
    r"""Ciphers included for your enrollment while deploying it on the network."""
    quic_enabled: bool
    r"""QUIC transport layer network protocol."""
    sni_only: bool
    r"""Server Name Indication (SNI) setting for this Enrollment."""
    disallowed_tls_versions: NotRequired[List[str]]
    r"""Disallowed TLS protocols."""
    dns_name_settings: NotRequired[
        Nullable[GetChangeAllowedInputParamDNSNameSettingsTypedDict]
    ]
    r"""DNS name settings."""
    network_type: NotRequired[Nullable[str]]
    r"""Enrollment network type."""
    ocsp_stapling: NotRequired[str]
    r"""OCSP stapling setting for the deployment."""


class GetChangeAllowedInputParamChangesPendingNetworkConfiguration(BaseModel):
    r"""The snapshot of the pending network configuration for the enrollment when this change takes effect."""

    must_have_ciphers: Annotated[str, pydantic.Field(alias="mustHaveCiphers")]
    r"""Ciphers included for your enrollment while deploying it on the network."""

    preferred_ciphers: Annotated[str, pydantic.Field(alias="preferredCiphers")]
    r"""Ciphers included for your enrollment while deploying it on the network."""

    quic_enabled: Annotated[bool, pydantic.Field(alias="quicEnabled")]
    r"""QUIC transport layer network protocol."""

    sni_only: Annotated[bool, pydantic.Field(alias="sniOnly")]
    r"""Server Name Indication (SNI) setting for this Enrollment."""

    disallowed_tls_versions: Annotated[
        Optional[List[str]], pydantic.Field(alias="disallowedTlsVersions")
    ] = None
    r"""Disallowed TLS protocols."""

    dns_name_settings: Annotated[
        OptionalNullable[GetChangeAllowedInputParamDNSNameSettings],
        pydantic.Field(alias="dnsNameSettings"),
    ] = UNSET
    r"""DNS name settings."""

    network_type: Annotated[
        OptionalNullable[str], pydantic.Field(alias="networkType")
    ] = UNSET
    r"""Enrollment network type."""

    ocsp_stapling: Annotated[Optional[str], pydantic.Field(alias="ocspStapling")] = None
    r"""OCSP stapling setting for the deployment."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "disallowedTlsVersions",
            "dnsNameSettings",
            "networkType",
            "ocspStapling",
        ]
        nullable_fields = ["dnsNameSettings", "networkType"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetChangeAllowedInputParamChangesPendingStateTypedDict(TypedDict):
    r"""The snapshot of the pending state for the enrollment when this change takes effect."""

    pending_network_configuration: (
        GetChangeAllowedInputParamChangesPendingNetworkConfigurationTypedDict
    )
    r"""The snapshot of the pending network configuration for the enrollment when this change takes effect."""
    pending_certificate: NotRequired[
        GetChangeAllowedInputParamChangesPendingCertificateTypedDict
    ]
    r"""The snapshot of the pending certificate for the enrollment when this change takes effect."""


class GetChangeAllowedInputParamChangesPendingState(BaseModel):
    r"""The snapshot of the pending state for the enrollment when this change takes effect."""

    pending_network_configuration: Annotated[
        GetChangeAllowedInputParamChangesPendingNetworkConfiguration,
        pydantic.Field(alias="pendingNetworkConfiguration"),
    ]
    r"""The snapshot of the pending network configuration for the enrollment when this change takes effect."""

    pending_certificate: Annotated[
        Optional[GetChangeAllowedInputParamChangesPendingCertificate],
        pydantic.Field(alias="pendingCertificate"),
    ] = None
    r"""The snapshot of the pending certificate for the enrollment when this change takes effect."""


class GetChangeAllowedInputParamChangesErrorsTypedDict(TypedDict):
    message: str
    r"""The description of the message."""
    message_code: str
    r"""The unique code of the message."""


class GetChangeAllowedInputParamChangesErrors(BaseModel):
    message: str
    r"""The description of the message."""

    message_code: Annotated[str, pydantic.Field(alias="messageCode")]
    r"""The unique code of the message."""


class GetChangeAllowedInputParamChangesWarningsTypedDict(TypedDict):
    message: str
    r"""The description of the message."""
    message_code: str
    r"""The unique code of the message."""


class GetChangeAllowedInputParamChangesWarnings(BaseModel):
    message: str
    r"""The description of the message."""

    message_code: Annotated[str, pydantic.Field(alias="messageCode")]
    r"""The unique code of the message."""


class GetChangeAllowedInputParamChangesValidationResultTypedDict(TypedDict):
    r"""Provides information about the hash's most recent validation check, indicating the change's current job state. This object appears in the response, even when its value is `null`. Before you run the [Update a change](ref:post-change-allowed-input-param) operation, review the change's validation results and resolve any issues."""

    errors: Nullable[List[GetChangeAllowedInputParamChangesErrorsTypedDict]]
    r"""Validation errors of the current job state. Errors prevent a change from proceeding until you resolve them. They are optional and only appear if there are any errors."""
    warnings: List[GetChangeAllowedInputParamChangesWarningsTypedDict]
    r"""Validation warnings of the current job state. Warnings suspend the execution of a change. You can acknowledge or deny warnings. If you acknowledge them, the change proceeds with its operation. They are optional and only appear if there are any warnings."""


class GetChangeAllowedInputParamChangesValidationResult(BaseModel):
    r"""Provides information about the hash's most recent validation check, indicating the change's current job state. This object appears in the response, even when its value is `null`. Before you run the [Update a change](ref:post-change-allowed-input-param) operation, review the change's validation results and resolve any issues."""

    errors: Nullable[List[GetChangeAllowedInputParamChangesErrors]]
    r"""Validation errors of the current job state. Errors prevent a change from proceeding until you resolve them. They are optional and only appear if there are any errors."""

    warnings: List[GetChangeAllowedInputParamChangesWarnings]
    r"""Validation warnings of the current job state. Warnings suspend the execution of a change. You can acknowledge or deny warnings. If you acknowledge them, the change proceeds with its operation. They are optional and only appear if there are any warnings."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["errors"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetChangeAllowedInputParamChangesResponseResponseBodyTypedDict(TypedDict):
    r"""After you create an enrollment, you can have CPS halt deployment when the certificate becomes available, so that you can test and view the certificate on a staging server prior to deployment in the production network. If you do not want CPS to automatically deploy the certificate to the production network after it receives the signed certificate from the CA, you can turn change management on for the enrollment. This stops CPS from deploying the certificate to the network until you acknowledge that you are ready to deploy the certificate."""

    pending_state: GetChangeAllowedInputParamChangesPendingStateTypedDict
    r"""The snapshot of the pending state for the enrollment when this change takes effect."""
    validation_result_hash: str
    r"""The hash of `validationResult`."""
    acknowledgement_deadline: NotRequired[Nullable[str]]
    r"""ISO 8601 timestamp for the user's deadline to acknowledge the change management validation result, before CPS attempts to deploy the pending state to the live network. The value is `null` if there's no existing certificate on the network for the current enrollment."""
    validation_result: NotRequired[
        GetChangeAllowedInputParamChangesValidationResultTypedDict
    ]
    r"""Provides information about the hash's most recent validation check, indicating the change's current job state. This object appears in the response, even when its value is `null`. Before you run the [Update a change](ref:post-change-allowed-input-param) operation, review the change's validation results and resolve any issues."""


class GetChangeAllowedInputParamChangesResponseResponseBody(BaseModel):
    r"""After you create an enrollment, you can have CPS halt deployment when the certificate becomes available, so that you can test and view the certificate on a staging server prior to deployment in the production network. If you do not want CPS to automatically deploy the certificate to the production network after it receives the signed certificate from the CA, you can turn change management on for the enrollment. This stops CPS from deploying the certificate to the network until you acknowledge that you are ready to deploy the certificate."""

    pending_state: Annotated[
        GetChangeAllowedInputParamChangesPendingState,
        pydantic.Field(alias="pendingState"),
    ]
    r"""The snapshot of the pending state for the enrollment when this change takes effect."""

    validation_result_hash: Annotated[str, pydantic.Field(alias="validationResultHash")]
    r"""The hash of `validationResult`."""

    acknowledgement_deadline: Annotated[
        OptionalNullable[str], pydantic.Field(alias="acknowledgementDeadline")
    ] = UNSET
    r"""ISO 8601 timestamp for the user's deadline to acknowledge the change management validation result, before CPS attempts to deploy the pending state to the live network. The value is `null` if there's no existing certificate on the network for the current enrollment."""

    validation_result: Annotated[
        Optional[GetChangeAllowedInputParamChangesValidationResult],
        pydantic.Field(alias="validationResult"),
    ] = None
    r"""Provides information about the hash's most recent validation check, indicating the change's current job state. This object appears in the response, even when its value is `null`. Before you run the [Update a change](ref:post-change-allowed-input-param) operation, review the change's validation results and resolve any issues."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["acknowledgementDeadline", "validationResult"]
        nullable_fields = ["acknowledgementDeadline"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetChangeAllowedInputParamCertificateType(str, Enum):
    r"""Either `san`, `single`, `wildcard`, `wildcard-san`, or `third-party`."""

    SAN = "san"
    SINGLE = "single"
    WILDCARD = "wildcard"
    WILDCARD_SAN = "wildcard-san"
    THIRD_PARTY = "third-party"


class GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsChangeManagementInfoV2PlusJSONSignatureAlgorithm(
    str, Enum
):
    r"""Displays the signature algorithm. Either `SHA-1` or `SHA-256`."""

    SHA_1 = "SHA-1"
    SHA_256 = "SHA-256"


class GetChangeAllowedInputParamPendingCertificateTypedDict(TypedDict):
    r"""The snapshot of the pending certificate for the enrollment when this change takes effect."""

    certificate_type: GetChangeAllowedInputParamCertificateType
    r"""Either `san`, `single`, `wildcard`, `wildcard-san`, or `third-party`."""
    full_certificate: str
    r"""Displays the contents of the certificate."""
    signature_algorithm: Nullable[
        GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsChangeManagementInfoV2PlusJSONSignatureAlgorithm
    ]
    r"""Displays the signature algorithm. Either `SHA-1` or `SHA-256`."""


class GetChangeAllowedInputParamPendingCertificate(BaseModel):
    r"""The snapshot of the pending certificate for the enrollment when this change takes effect."""

    certificate_type: Annotated[
        GetChangeAllowedInputParamCertificateType,
        pydantic.Field(alias="certificateType"),
    ]
    r"""Either `san`, `single`, `wildcard`, `wildcard-san`, or `third-party`."""

    full_certificate: Annotated[str, pydantic.Field(alias="fullCertificate")]
    r"""Displays the contents of the certificate."""

    signature_algorithm: Annotated[
        Nullable[
            GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsChangeManagementInfoV2PlusJSONSignatureAlgorithm
        ],
        pydantic.Field(alias="signatureAlgorithm"),
    ]
    r"""Displays the signature algorithm. Either `SHA-1` or `SHA-256`."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["signatureAlgorithm"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetChangeAllowedInputParamSniTypedDict(TypedDict):
    r"""Server Name Indication (SNI) setting for this enrollment."""

    clone_dns_names: bool
    r"""When `true`, all certificate SANs are included in `dnsNames`."""
    dns_names: NotRequired[Nullable[List[str]]]
    r"""Names served by SNI-only enabled enrollments."""


class GetChangeAllowedInputParamSni(BaseModel):
    r"""Server Name Indication (SNI) setting for this enrollment."""

    clone_dns_names: Annotated[bool, pydantic.Field(alias="cloneDnsNames")]
    r"""When `true`, all certificate SANs are included in `dnsNames`."""

    dns_names: Annotated[
        OptionalNullable[List[str]], pydantic.Field(alias="dnsNames")
    ] = UNSET
    r"""Names served by SNI-only enabled enrollments."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["dnsNames"]
        nullable_fields = ["dnsNames"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetChangeAllowedInputParamPendingNetworkConfigurationTypedDict(TypedDict):
    r"""The snapshot of the pending network configuration for the enrollment when this change takes effect."""

    disallowed_tls_versions: NotRequired[List[str]]
    r"""Disallowed TLS protocols."""
    must_have_ciphers: NotRequired[str]
    r"""Ciphers that you want to include for your enrollment while deploying it on the network. Defaults to `ak-akamai-default`."""
    network_type: NotRequired[Nullable[str]]
    r"""Enrollment network type."""
    preferred_ciphers: NotRequired[str]
    r"""Ciphers you want to include for your enrollment while deploying it on the network. Defaults to `ak-akamai-default`."""
    sni: NotRequired[Nullable[GetChangeAllowedInputParamSniTypedDict]]
    r"""Server Name Indication (SNI) setting for this enrollment."""


class GetChangeAllowedInputParamPendingNetworkConfiguration(BaseModel):
    r"""The snapshot of the pending network configuration for the enrollment when this change takes effect."""

    disallowed_tls_versions: Annotated[
        Optional[List[str]], pydantic.Field(alias="disallowedTlsVersions")
    ] = None
    r"""Disallowed TLS protocols."""

    must_have_ciphers: Annotated[
        Optional[str], pydantic.Field(alias="mustHaveCiphers")
    ] = "ak-akamai-default"
    r"""Ciphers that you want to include for your enrollment while deploying it on the network. Defaults to `ak-akamai-default`."""

    network_type: Annotated[
        OptionalNullable[str], pydantic.Field(alias="networkType")
    ] = UNSET
    r"""Enrollment network type."""

    preferred_ciphers: Annotated[
        Optional[str], pydantic.Field(alias="preferredCiphers")
    ] = "ak-akamai-default"
    r"""Ciphers you want to include for your enrollment while deploying it on the network. Defaults to `ak-akamai-default`."""

    sni: OptionalNullable[GetChangeAllowedInputParamSni] = UNSET
    r"""Server Name Indication (SNI) setting for this enrollment."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "disallowedTlsVersions",
            "mustHaveCiphers",
            "networkType",
            "preferredCiphers",
            "sni",
        ]
        nullable_fields = ["networkType", "sni"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetChangeAllowedInputParamPendingStateTypedDict(TypedDict):
    r"""The snapshot of the pending state for the enrollment when this change takes effect."""

    pending_network_configuration: (
        GetChangeAllowedInputParamPendingNetworkConfigurationTypedDict
    )
    r"""The snapshot of the pending network configuration for the enrollment when this change takes effect."""
    pending_certificate: NotRequired[
        GetChangeAllowedInputParamPendingCertificateTypedDict
    ]
    r"""The snapshot of the pending certificate for the enrollment when this change takes effect."""


class GetChangeAllowedInputParamPendingState(BaseModel):
    r"""The snapshot of the pending state for the enrollment when this change takes effect."""

    pending_network_configuration: Annotated[
        GetChangeAllowedInputParamPendingNetworkConfiguration,
        pydantic.Field(alias="pendingNetworkConfiguration"),
    ]
    r"""The snapshot of the pending network configuration for the enrollment when this change takes effect."""

    pending_certificate: Annotated[
        Optional[GetChangeAllowedInputParamPendingCertificate],
        pydantic.Field(alias="pendingCertificate"),
    ] = None
    r"""The snapshot of the pending certificate for the enrollment when this change takes effect."""


class GetChangeAllowedInputParamErrorsTypedDict(TypedDict):
    message: str
    r"""The description of the message."""
    message_code: str
    r"""The unique code of the message."""


class GetChangeAllowedInputParamErrors(BaseModel):
    message: str
    r"""The description of the message."""

    message_code: Annotated[str, pydantic.Field(alias="messageCode")]
    r"""The unique code of the message."""


class GetChangeAllowedInputParamWarningsTypedDict(TypedDict):
    message: str
    r"""The description of the message."""
    message_code: str
    r"""The unique code of the message."""


class GetChangeAllowedInputParamWarnings(BaseModel):
    message: str
    r"""The description of the message."""

    message_code: Annotated[str, pydantic.Field(alias="messageCode")]
    r"""The unique code of the message."""


class GetChangeAllowedInputParamValidationResultTypedDict(TypedDict):
    r"""Provides information about the hash's most recent validation check, indicating the change's current job state. This object appears in the response, even when its value is `null`. Before you run the [Update a change](ref:post-change-allowed-input-param) operation, review the change's validation results and resolve any issues."""

    errors: Nullable[List[GetChangeAllowedInputParamErrorsTypedDict]]
    r"""Validation errors of the current job state. Errors prevent a change from proceeding until you resolve them. They are optional and only appear if there are any errors."""
    warnings: List[GetChangeAllowedInputParamWarningsTypedDict]
    r"""Validation warnings of the current job state. Warnings suspend the execution of a change. You can acknowledge or deny warnings. If you acknowledge them, the change proceeds with its operation. They are optional and only appear if there are any warnings."""


class GetChangeAllowedInputParamValidationResult(BaseModel):
    r"""Provides information about the hash's most recent validation check, indicating the change's current job state. This object appears in the response, even when its value is `null`. Before you run the [Update a change](ref:post-change-allowed-input-param) operation, review the change's validation results and resolve any issues."""

    errors: Nullable[List[GetChangeAllowedInputParamErrors]]
    r"""Validation errors of the current job state. Errors prevent a change from proceeding until you resolve them. They are optional and only appear if there are any errors."""

    warnings: List[GetChangeAllowedInputParamWarnings]
    r"""Validation warnings of the current job state. Warnings suspend the execution of a change. You can acknowledge or deny warnings. If you acknowledge them, the change proceeds with its operation. They are optional and only appear if there are any warnings."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["errors"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetChangeAllowedInputParamChangesResponseBodyTypedDict(TypedDict):
    r"""After you create an enrollment, you can have CPS halt deployment when the certificate becomes available, so that you can test and view the certificate on a staging server prior to deployment in the production network. If you do not want CPS to automatically deploy the certificate to the production network after it receives the signed certificate from the CA, you can turn change management on for the enrollment. This stops CPS from deploying the certificate to the network until you acknowledge that you are ready to deploy the certificate."""

    pending_state: GetChangeAllowedInputParamPendingStateTypedDict
    r"""The snapshot of the pending state for the enrollment when this change takes effect."""
    validation_result_hash: str
    r"""The hash of `validationResult`."""
    acknowledgement_deadline: NotRequired[Nullable[str]]
    r"""ISO 8601 timestamp for the user's deadline to acknowledge the change management validation result, before CPS attempts to deploy the pending state to the live network. The value is `null` if there's no existing certificate on the network for the current enrollment."""
    validation_result: NotRequired[GetChangeAllowedInputParamValidationResultTypedDict]
    r"""Provides information about the hash's most recent validation check, indicating the change's current job state. This object appears in the response, even when its value is `null`. Before you run the [Update a change](ref:post-change-allowed-input-param) operation, review the change's validation results and resolve any issues."""


class GetChangeAllowedInputParamChangesResponseBody(BaseModel):
    r"""After you create an enrollment, you can have CPS halt deployment when the certificate becomes available, so that you can test and view the certificate on a staging server prior to deployment in the production network. If you do not want CPS to automatically deploy the certificate to the production network after it receives the signed certificate from the CA, you can turn change management on for the enrollment. This stops CPS from deploying the certificate to the network until you acknowledge that you are ready to deploy the certificate."""

    pending_state: Annotated[
        GetChangeAllowedInputParamPendingState, pydantic.Field(alias="pendingState")
    ]
    r"""The snapshot of the pending state for the enrollment when this change takes effect."""

    validation_result_hash: Annotated[str, pydantic.Field(alias="validationResultHash")]
    r"""The hash of `validationResult`."""

    acknowledgement_deadline: Annotated[
        OptionalNullable[str], pydantic.Field(alias="acknowledgementDeadline")
    ] = UNSET
    r"""ISO 8601 timestamp for the user's deadline to acknowledge the change management validation result, before CPS attempts to deploy the pending state to the live network. The value is `null` if there's no existing certificate on the network for the current enrollment."""

    validation_result: Annotated[
        Optional[GetChangeAllowedInputParamValidationResult],
        pydantic.Field(alias="validationResult"),
    ] = None
    r"""Provides information about the hash's most recent validation check, indicating the change's current job state. This object appears in the response, even when its value is `null`. Before you run the [Update a change](ref:post-change-allowed-input-param) operation, review the change's validation results and resolve any issues."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["acknowledgementDeadline", "validationResult"]
        nullable_fields = ["acknowledgementDeadline"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class PendingCertificateTypedDict(TypedDict):
    r"""The snapshot of the pending certificate for the enrollment when this change takes effect."""

    certificate_type: str
    r"""The kind of certificate created."""
    full_certificate: str
    r"""Displays the contents of the certificate."""
    signature_algorithm: Nullable[str]
    r"""Displays the signature algorithm."""


class PendingCertificate(BaseModel):
    r"""The snapshot of the pending certificate for the enrollment when this change takes effect."""

    certificate_type: Annotated[str, pydantic.Field(alias="certificateType")]
    r"""The kind of certificate created."""

    full_certificate: Annotated[str, pydantic.Field(alias="fullCertificate")]
    r"""Displays the contents of the certificate."""

    signature_algorithm: Annotated[
        Nullable[str], pydantic.Field(alias="signatureAlgorithm")
    ]
    r"""Displays the signature algorithm."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["signatureAlgorithm"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetChangeAllowedInputParamChangesSniTypedDict(TypedDict):
    r"""Server Name Indication (SNI) setting for this Enrollment."""

    clone_dns_names: bool
    r"""Descriptive text for the cloned DNS."""
    dns_names: NotRequired[Nullable[List[str]]]
    r"""Descriptive text for the DNS served by SNI-only enabled enrollments."""


class GetChangeAllowedInputParamChangesSni(BaseModel):
    r"""Server Name Indication (SNI) setting for this Enrollment."""

    clone_dns_names: Annotated[bool, pydantic.Field(alias="cloneDnsNames")]
    r"""Descriptive text for the cloned DNS."""

    dns_names: Annotated[
        OptionalNullable[List[str]], pydantic.Field(alias="dnsNames")
    ] = UNSET
    r"""Descriptive text for the DNS served by SNI-only enabled enrollments."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["dnsNames"]
        nullable_fields = ["dnsNames"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class PendingNetworkConfigurationTypedDict(TypedDict):
    r"""The snapshot of the pending network configuration for the enrollment when this change takes effect."""

    must_have_ciphers: str
    r"""Ciphers that you want to include for your enrollment while deploying it on the network. Defaults to `ak-akamai-default`."""
    network_type: NotRequired[Nullable[str]]
    r"""The kind of enrollment network."""
    preferred_ciphers: NotRequired[str]
    r"""Ciphers that you preferably want to include for your enrollment while deploying it on the network. Defaults to `ak-akamai-default`."""
    sni: NotRequired[Nullable[GetChangeAllowedInputParamChangesSniTypedDict]]
    r"""Server Name Indication (SNI) setting for this Enrollment."""


class PendingNetworkConfiguration(BaseModel):
    r"""The snapshot of the pending network configuration for the enrollment when this change takes effect."""

    must_have_ciphers: Annotated[str, pydantic.Field(alias="mustHaveCiphers")]
    r"""Ciphers that you want to include for your enrollment while deploying it on the network. Defaults to `ak-akamai-default`."""

    network_type: Annotated[
        OptionalNullable[str], pydantic.Field(alias="networkType")
    ] = UNSET
    r"""The kind of enrollment network."""

    preferred_ciphers: Annotated[
        Optional[str], pydantic.Field(alias="preferredCiphers")
    ] = "ak-akamai-default"
    r"""Ciphers that you preferably want to include for your enrollment while deploying it on the network. Defaults to `ak-akamai-default`."""

    sni: OptionalNullable[GetChangeAllowedInputParamChangesSni] = UNSET
    r"""Server Name Indication (SNI) setting for this Enrollment."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["networkType", "preferredCiphers", "sni"]
        nullable_fields = ["networkType", "sni"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class PendingStateTypedDict(TypedDict):
    r"""The snapshot of the pending state for the enrollment when this change takes effect."""

    pending_network_configuration: PendingNetworkConfigurationTypedDict
    r"""The snapshot of the pending network configuration for the enrollment when this change takes effect."""
    pending_certificate: NotRequired[PendingCertificateTypedDict]
    r"""The snapshot of the pending certificate for the enrollment when this change takes effect."""


class PendingState(BaseModel):
    r"""The snapshot of the pending state for the enrollment when this change takes effect."""

    pending_network_configuration: Annotated[
        PendingNetworkConfiguration, pydantic.Field(alias="pendingNetworkConfiguration")
    ]
    r"""The snapshot of the pending network configuration for the enrollment when this change takes effect."""

    pending_certificate: Annotated[
        Optional[PendingCertificate], pydantic.Field(alias="pendingCertificate")
    ] = None
    r"""The snapshot of the pending certificate for the enrollment when this change takes effect."""


class ErrorsTypedDict(TypedDict):
    message: str
    r"""Descriptive text for the error."""
    message_code: str
    r"""Unique code for the error."""


class Errors(BaseModel):
    message: str
    r"""Descriptive text for the error."""

    message_code: Annotated[str, pydantic.Field(alias="messageCode")]
    r"""Unique code for the error."""


class WarningsTypedDict(TypedDict):
    message: str
    r"""Descriptive text for the warning."""
    message_code: str
    r"""Unique code for the warning."""


class Warnings(BaseModel):
    message: str
    r"""Descriptive text for the warning."""

    message_code: Annotated[str, pydantic.Field(alias="messageCode")]
    r"""Unique code for the warning."""


class ValidationResultTypedDict(TypedDict):
    r"""Provides information about the hash's most recent validation check, indicating the change's current job state. This object appears in the response, even when its value is `null`. Before you run the [Update a change](ref:post-change-allowed-input-param) operation, review the change's validation results and resolve any issues."""

    errors: Nullable[List[ErrorsTypedDict]]
    r"""Validation errors of the current job state. Errors prevent a change from proceeding until you resolve them. They are optional and only appear if there are any errors."""
    warnings: List[WarningsTypedDict]
    r"""Validation warnings of the current job state. Warnings suspend the execution of a change. You can acknowledge or deny warnings. If you acknowledge them, the change proceeds with its operation. They are optional and only appear if there are any warnings."""


class ValidationResult(BaseModel):
    r"""Provides information about the hash's most recent validation check, indicating the change's current job state. This object appears in the response, even when its value is `null`. Before you run the [Update a change](ref:post-change-allowed-input-param) operation, review the change's validation results and resolve any issues."""

    errors: Nullable[List[Errors]]
    r"""Validation errors of the current job state. Errors prevent a change from proceeding until you resolve them. They are optional and only appear if there are any errors."""

    warnings: List[Warnings]
    r"""Validation warnings of the current job state. Warnings suspend the execution of a change. You can acknowledge or deny warnings. If you acknowledge them, the change proceeds with its operation. They are optional and only appear if there are any warnings."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["errors"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetChangeAllowedInputParamResponseBodyTypedDict(TypedDict):
    r"""After you create an enrollment, you can have CPS halt deployment when the certificate becomes available, so that you can test and view the certificate on a staging server prior to deployment in the production network. If you do not want CPS to automatically deploy the certificate to the production network after it receives the signed certificate from the CA, you can turn change management on for the enrollment. This stops CPS from deploying the certificate to the network until you acknowledge that you are ready to deploy the certificate. A version label indicates this member is introduced in that version. A pre-version label indicates this member is removed in that version. No version label indicates this member is present in all versions."""

    pending_state: PendingStateTypedDict
    r"""The snapshot of the pending state for the enrollment when this change takes effect."""
    validation_result_hash: str
    r"""The hash of the validation result."""
    acknowledgement_deadline: NotRequired[Nullable[str]]
    r"""ISO 8601 timestamp for the user's deadline to acknowledge the change management validation result, before CPS deploys the pending state to the live network. The value is `null` if there's no existing certificate on the network for the current enrollment."""
    validation_result: NotRequired[ValidationResultTypedDict]
    r"""Provides information about the hash's most recent validation check, indicating the change's current job state. This object appears in the response, even when its value is `null`. Before you run the [Update a change](ref:post-change-allowed-input-param) operation, review the change's validation results and resolve any issues."""


class GetChangeAllowedInputParamResponseBody(BaseModel):
    r"""After you create an enrollment, you can have CPS halt deployment when the certificate becomes available, so that you can test and view the certificate on a staging server prior to deployment in the production network. If you do not want CPS to automatically deploy the certificate to the production network after it receives the signed certificate from the CA, you can turn change management on for the enrollment. This stops CPS from deploying the certificate to the network until you acknowledge that you are ready to deploy the certificate. A version label indicates this member is introduced in that version. A pre-version label indicates this member is removed in that version. No version label indicates this member is present in all versions."""

    pending_state: Annotated[PendingState, pydantic.Field(alias="pendingState")]
    r"""The snapshot of the pending state for the enrollment when this change takes effect."""

    validation_result_hash: Annotated[str, pydantic.Field(alias="validationResultHash")]
    r"""The hash of the validation result."""

    acknowledgement_deadline: Annotated[
        OptionalNullable[str], pydantic.Field(alias="acknowledgementDeadline")
    ] = UNSET
    r"""ISO 8601 timestamp for the user's deadline to acknowledge the change management validation result, before CPS deploys the pending state to the live network. The value is `null` if there's no existing certificate on the network for the current enrollment."""

    validation_result: Annotated[
        Optional[ValidationResult], pydantic.Field(alias="validationResult")
    ] = None
    r"""Provides information about the hash's most recent validation check, indicating the change's current job state. This object appears in the response, even when its value is `null`. Before you run the [Update a change](ref:post-change-allowed-input-param) operation, review the change's validation results and resolve any issues."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["acknowledgementDeadline", "validationResult"]
        nullable_fields = ["acknowledgementDeadline"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


GetChangeAllowedInputParamResponseTypedDict = Union[
    GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsCsrV1PlusJSONResponseBodyTypedDict,
    GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsWarningsV1PlusJSONResponseBodyTypedDict,
    GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsDvChallengesV2PlusJSONResponseBodyTypedDict,
    GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsDvChallengesV1PlusJSONResponseBodyTypedDict,
    GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsCsrV2PlusJSONResponseBodyTypedDict,
    GetChangeAllowedInputParamChangesResponse200ResponseBodyTypedDict,
    GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsChangeManagementInfoV6PlusJSONResponseBodyTypedDict,
    GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsDeploymentV3PlusJSONResponseBodyTypedDict,
    GetChangeAllowedInputParamResponseBodyTypedDict,
    GetChangeAllowedInputParamChangesResponseResponseBodyTypedDict,
    GetChangeAllowedInputParamChangesResponseBodyTypedDict,
    GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsDeploymentV6PlusJSONResponseBodyTypedDict,
    GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsDeploymentV7PlusJSONResponseBodyTypedDict,
    GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsDeploymentV8PlusJSONResponseBodyTypedDict,
]


GetChangeAllowedInputParamResponse = Union[
    GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsCsrV1PlusJSONResponseBody,
    GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsWarningsV1PlusJSONResponseBody,
    GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsDvChallengesV2PlusJSONResponseBody,
    GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsDvChallengesV1PlusJSONResponseBody,
    GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsCsrV2PlusJSONResponseBody,
    GetChangeAllowedInputParamChangesResponse200ResponseBody,
    GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsChangeManagementInfoV6PlusJSONResponseBody,
    GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsDeploymentV3PlusJSONResponseBody,
    GetChangeAllowedInputParamResponseBody,
    GetChangeAllowedInputParamChangesResponseResponseBody,
    GetChangeAllowedInputParamChangesResponseBody,
    GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsDeploymentV6PlusJSONResponseBody,
    GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsDeploymentV7PlusJSONResponseBody,
    GetChangeAllowedInputParamChangesResponse200ApplicationVndAkamaiCpsDeploymentV8PlusJSONResponseBody,
]
